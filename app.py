# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15xUsIc96lG4x4uuG39sa5PhoT7xVnVjz
"""

from fastapi import FastAPI
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime
import requests
import pandas as pd
import joblib
import numpy as np

# =========================
# ğŸ”§ torch (ì˜µì…˜) â€“ ì‹¤íŒ¨í•˜ë©´ GNN ë¹„í™œì„±í™”
# =========================
try:
    import torch
    TORCH_AVAILABLE = True
except Exception as e:
    TORCH_AVAILABLE = False
    print("âš ï¸ torchë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. GNN ì„ë² ë”©ì„ ë¹„í™œì„±í™”í•©ë‹ˆë‹¤:", e)

# =========================
# ğŸ”§ OpenWeather ì„¤ì •
# =========================
OWM_API_KEY = "9f8737894290204a7b2793f510443e46"
OWM_GEOCODE_URL = "http://api.openweathermap.org/geo/1.0/direct"
OWM_FORECAST_URL = "https://api.openweathermap.org/data/2.5/forecast"   # 5ì¼ / 3ì‹œê°„ ì˜ˆë³´
OWM_AIR_URL = "http://api.openweathermap.org/data/2.5/air_pollution"    # í˜„ì¬ ëŒ€ê¸°ì§ˆ

# =========================
# ğŸ¯ í•™ìŠµëœ ëª¨ë¸/ìŠ¤ì¼€ì¼ëŸ¬/ì¸ì½”ë” ë¡œë“œ
# =========================
category_model = joblib.load("category_model.pkl")
scaler = joblib.load("feature_scaler.pkl")
le_category = joblib.load("category_label_encoder.pkl")

# =========================
# ğŸ“‚ CSV ë¡œë“œ (ìš´ë™ ë©”íƒ€ë°ì´í„°)
# =========================
activity_df = pd.read_csv("activity_information.csv")
activity_df = activity_df.rename(
    columns={
        "í™œë™ëª…": "activity_name",
        "í™œë™ì¹´í…Œê³ ë¦¬": "category",
        "ì¥ì†Œìœ í˜•": "location_type",
        "ë‚œì´ë„": "difficulty",
        "ì¶”ì²œê³„ì ˆ": "season",
        "ì í•©ì‹œê°„ëŒ€": "time_range",
    }
)

season_map = {"ë´„": 0, "ì—¬ë¦„": 1, "ê°€ì„": 2, "ê²¨ìš¸": 3}

# =========================
# ğŸ§  GNN ì„ë² ë”© ë¡œë“œ
# =========================
if TORCH_AVAILABLE:
    try:
        gnn_obj = torch.load("activity_gnn_embeddings.pt", map_location="cpu")
        ACT_EMB = gnn_obj["activity_embeddings"]        # [num_acts, dim]
        ACT2IDX = gnn_obj["act2idx"]                   # {activity_name: idx}
        ACT_EMB = torch.nn.functional.normalize(ACT_EMB, dim=1)  # cosineìš© ì •ê·œí™”
        print("âœ… GNN activity embeddings loaded.")
    except Exception as e:
        ACT_EMB = None
        ACT2IDX = {}
        print("âš ï¸ GNN embeddings not loaded:", e)
else:
    ACT_EMB = None
    ACT2IDX = {}
    print("âš ï¸ torchê°€ ì—†ì–´ GNN ì„ë² ë”©ì„ ì‚¬ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")

# =========================
# ğŸ§© Pydantic ìš”ì²­ ìŠ¤í‚¤ë§ˆ
# =========================
class LocationUserRequest(BaseModel):
    user_id: str
    location_name: str
    target_datetime: datetime
    favorites: Optional[List[str]] = None  # UIì—ì„œ ì‹¤ì‹œê°„ìœ¼ë¡œ ë°›ì€ ì„ í˜¸ìš´ë™ ë¦¬ìŠ¤íŠ¸


# =========================
# ğŸ”§ ê³„ì ˆ / ì‹œê°„ëŒ€ / ê³µê¸°ì§ˆ ìœ í‹¸
# =========================
def get_season_from_month(m: int) -> str:
    if 3 <= m <= 5:
        return "ë´„"
    if 6 <= m <= 8:
        return "ì—¬ë¦„"
    if 9 <= m <= 11:
        return "ê°€ì„"
    return "ê²¨ìš¸"


def get_time_range_from_hour(h: int) -> str:
    if 5 <= h < 12:
        return "ì˜¤ì „"
    if 12 <= h < 18:
        return "ì˜¤í›„"
    if 18 <= h < 23:
        return "ì €ë…"
    return "ì•¼ê°„"


def classify_pm(pm25: float, pm10: float) -> str:
    # ê°„ë‹¨ í•œêµ­ í™˜ê²½ ê¸°ì¤€ ê·¼ì‚¬ ë²„ì „
    if pm25 <= 15 and pm10 <= 30:
        return "ì¢‹ìŒ"
    if pm25 <= 35 and pm10 <= 80:
        return "ë³´í†µ"
    if pm25 <= 75 and pm10 <= 150:
        return "ë‚˜ì¨"
    return "ë§¤ìš° ë‚˜ì¨"


# =========================
# ğŸŒ Geocoding â€“ OpenWeatherMap + Fallback
# =========================
def geocode_owm(location_name: str):
    """
    OpenWeatherMap Geocoding.
    - 1ì°¨: ê·¸ëŒ€ë¡œ location_nameìœ¼ë¡œ ê²€ìƒ‰
    - 2ì°¨: ",KR" ë¶™ì—¬ì„œ ê²€ìƒ‰
    - 3ì°¨: 'ì„±ë‚¨ì‹œ ìˆ˜ì •êµ¬' â†’ 'ì„±ë‚¨ì‹œ' ê°™ì€ ë„ì‹œ ë‹¨ìœ„ë¡œ ì¶•ì•½í•´ì„œ ì¬ì‹œë„
    """

    def call_geocode(q: str):
        params = {
            "q": q,
            "limit": 1,
            "appid": OWM_API_KEY,
        }
        r = requests.get(OWM_GEOCODE_URL, params=params)
        r.raise_for_status()
        return r.json()

    queries = []

    # 1) ì›ë³¸ ê·¸ëŒ€ë¡œ
    queries.append(location_name)
    queries.append(f"{location_name},KR")

    # 2) 'ì„±ë‚¨ì‹œ ìˆ˜ì •êµ¬' â†’ 'ì„±ë‚¨ì‹œ'
    tokens = location_name.split()
    if tokens:
        city_token = None
        for t in tokens:
            if t.endswith("ì‹œ"):
                city_token = t
                break
        if city_token is None:
            city_token = tokens[0]

        queries.append(city_token)
        queries.append(f"{city_token},KR")

    # ì‹¤ì œ í˜¸ì¶œ ì‹œë„
    for q in queries:
        try:
            data = call_geocode(q)
        except Exception:
            continue

        if data:
            lat = float(data[0]["lat"])
            lon = float(data[0]["lon"])
            return lat, lon

    # ì „ë¶€ ì‹¤íŒ¨í•˜ë©´ ì—ëŸ¬
    raise ValueError(
        f"'{location_name}' ì— ëŒ€í•œ ì¢Œí‘œë¥¼ OpenWeatherMapì—ì„œ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. "
        f"ë„ì‹œ ì´ë¦„ë§Œ(ì˜ˆ: 'ì„±ë‚¨ì‹œ' ë˜ëŠ” 'Seongnam-si')ìœ¼ë¡œ ë‹¤ì‹œ ì‹œë„í•´ ë³´ì„¸ìš”."
    )


# =========================
# ğŸŒ¦ OpenWeather 5ì¼ ì˜ˆë³´ + 1ì‹œê°„ ê°„ê²© ë³´ê°„ + Air Pollution
# =========================
def get_weather_from_owm(lat: float, lon: float, target_dt: datetime):
    # 1) 5ì¼ / 3ì‹œê°„ ì˜ˆë³´
    params = {
        "lat": lat,
        "lon": lon,
        "appid": OWM_API_KEY,
        "units": "metric",
        "lang": "kr",
    }
    r = requests.get(OWM_FORECAST_URL, params=params)
    r.raise_for_status()
    data = r.json()

    items = data.get("list", [])
    if not items:
        raise RuntimeError("OpenWeather 5ì¼ ì˜ˆë³´ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")

    rows = []
    for it in items:
        dt_txt = it.get("dt_txt")
        if not dt_txt:
            continue

        main = it.get("main", {})
        wind = it.get("wind", {})
        rain = it.get("rain", {})

        temp = main.get("temp")
        hum = main.get("humidity")
        ws = wind.get("speed", 0.0)
        precip = rain.get("3h", 0.0) or 0.0

        rows.append(
            {
                "dt": pd.to_datetime(dt_txt),
                "temperature": float(temp) if temp is not None else None,
                "humidity": float(hum) if hum is not None else None,
                "wind_speed": float(ws),
                "precipitation": float(precip),
            }
        )

    df = pd.DataFrame(rows).set_index("dt").sort_index()

    # 3ì‹œê°„ â†’ 1ì‹œê°„ìœ¼ë¡œ resample (ì´ì „ ê°’ ìœ ì§€)
    df_1h = df.resample("1H").ffill()

    # target_dtê°€ ë²”ìœ„ ë°–ì´ë©´ ê°€ì¥ ê°€ê¹Œìš´ ì‹œì ìœ¼ë¡œ ë³´ì •
    if target_dt < df_1h.index.min():
        chosen_ts = df_1h.index.min()
    elif target_dt > df_1h.index.max():
        chosen_ts = df_1h.index.max()
    else:
        idx = df_1h.index.get_indexer([target_dt], method="nearest")[0]
        chosen_ts = df_1h.index[idx]

    row = df_1h.loc[chosen_ts]

    # 2) ëŒ€ê¸°ì§ˆ (í˜„ì¬ê°’ ì‚¬ìš© â€“ ë‹¨ìˆœí™”)
    air_params = {
        "lat": lat,
        "lon": lon,
        "appid": OWM_API_KEY,
    }
    air_r = requests.get(OWM_AIR_URL, params=air_params)
    pm25 = 0.0
    pm10 = 0.0
    try:
        air_r.raise_for_status()
        air_data = air_r.json()
        first = air_data.get("list", [{}])[0]
        comps = first.get("components", {})
        pm25 = float(comps.get("pm2_5", 0.0))
        pm10 = float(comps.get("pm10", 0.0))
    except Exception:
        pm25 = 0.0
        pm10 = 0.0

    return {
        "temperature": float(row["temperature"]),
        "humidity": float(row["humidity"]),
        "wind_speed": float(row["wind_speed"]),
        "precipitation": float(row["precipitation"]),
        "pm25": pm25,
        "pm10": pm10,
        "raw_dt": chosen_ts.strftime("%Y-%m-%d %H:%M:%S"),
    }


# =========================
# ğŸš€ FastAPI ì•±
# =========================
app = FastAPI(
    title="OpenWeather ê¸°ë°˜ AI ìš´ë™ ì¶”ì²œ API",
    description="ìœ„ì¹˜ + ì‹œê°„ + ì‹¤ì‹œê°„ ì„ í˜¸ìš´ë™ + ë‚ ì”¨/ë¯¸ì„¸ë¨¼ì§€ + GNNìœ¼ë¡œ ìµœì  ìš´ë™ ì¶”ì²œ",
    version="1.1",
)


@app.get("/")
def home():
    return {"message": "ìš´ë™ ì¶”ì²œ API ì‘ë™ ì¤‘!"}


# =========================
# ğŸ§  GNN ìœ í‹¸ í•¨ìˆ˜
# =========================
def get_user_embedding_from_favorites(favorite_list: List[str]):
    """
    ì„ í˜¸ìš´ë™ë“¤ì— í•´ë‹¹í•˜ëŠ” í™œë™ ì„ë² ë”©ì„ í‰ê· í•´ì„œ ì‚¬ìš©ì ë²¡í„°ë¡œ ì‚¬ìš©
    (simple ë²„ì „)
    """
    if ACT_EMB is None or not favorite_list:
        return None

    idx_list = []
    for name in favorite_list:
        if name in ACT2IDX:
            idx_list.append(ACT2IDX[name])

    if not idx_list:
        return None

    mat = ACT_EMB[idx_list]                 # [k, dim]
    user_vec = mat.mean(dim=0, keepdim=True)  # [1, dim]
    user_vec = torch.nn.functional.normalize(user_vec, dim=1)
    return user_vec  # [1, dim]


def gnn_similarity_score(user_vec, activity_name: str) -> float:
    """
    user_vec: [1, dim] (normalized)
    activity_name: str
    """
    if ACT_EMB is None or user_vec is None:
        return 0.0
    if activity_name not in ACT2IDX:
        return 0.0

    idx = ACT2IDX[activity_name]
    act_vec = ACT_EMB[idx: idx + 1]  # [1, dim]
    sim = float((user_vec * act_vec).sum().item())  # cosine (ë‘˜ ë‹¤ ì •ê·œí™”ëœ ìƒíƒœ)
    return sim  # -1 ~ 1 ê·¼ì‚¬


# =========================
# â­ ì½˜í…ì¸  + GNN ê¸°ë°˜ ìŠ¤ì½”ì–´ë§ í•¨ìˆ˜
# =========================
def score_activity(
    activity_row: pd.Series,
    favorite_set,
    indoor_required: bool,
    season_str: str,
    time_range_str: str,
    user_vec=None,
):
    """
    í•œ í™œë™(row)ì— ëŒ€í•´ ì„ í˜¸ìš´ë™/ì‹¤ë‚´Â·ì‹¤ì™¸/ê³„ì ˆ/ì‹œê°„ëŒ€ + GNN ìœ ì‚¬ë„ë¥¼ ë°˜ì˜í•œ ì ìˆ˜ ê³„ì‚°
    """
    score = 0.0

    name = str(activity_row.get("activity_name", ""))
    location_type = str(activity_row.get("location_type", ""))
    season = str(activity_row.get("season", ""))
    time_range = str(activity_row.get("time_range", ""))

    # 1) ì„ í˜¸ìš´ë™ ì´ë¦„ê³¼ ì¼ì¹˜í•˜ë©´ í° ê°€ì 
    if name in favorite_set:
        score += 3.0

    # 2) ì‹¤ë‚´/ì‹¤ì™¸ ì¡°ê±´ê³¼ ì¼ì¹˜ ì—¬ë¶€
    if indoor_required:
        if "ì‹¤ë‚´" in location_type:
            score += 2.0
    else:
        if "ì‹¤ì™¸" in location_type:
            score += 2.0

    # 3) ì¶”ì²œ ê³„ì ˆ/ì‹œê°„ëŒ€ì™€ í˜„ì¬ê°€ ë§ìœ¼ë©´ ê°€ì 
    if season_str and season_str in season:
        score += 1.0
    if time_range_str and time_range_str in time_range:
        score += 1.0

    # 4) GNN ìœ ì‚¬ë„ ì ìˆ˜ (ìµœëŒ€ 2ì  ì •ë„ ë¹„ì¤‘)
    if user_vec is not None:
        sim = gnn_similarity_score(user_vec, name)      # -1 ~ 1
        score += 2.0 * ((sim + 1.0) / 2.0)              # 0 ~ 2 ë¡œ ìŠ¤ì¼€ì¼ë§

    return score


# =========================
# ğŸ§  í•µì‹¬ ì—”ë“œí¬ì¸íŠ¸
# =========================
@app.post("/recommend/by-location-and-user")
def recommend_by_location_and_user(req: LocationUserRequest):
    # 1) ìœ„ì¹˜ â†’ ìœ„/ê²½ë„
    lat, lon = geocode_owm(req.location_name)

    # 2) í•´ë‹¹ ì‹œì ì˜ ë‚ ì”¨ + ëŒ€ê¸°ì§ˆ
    weather = get_weather_from_owm(lat, lon, req.target_datetime)

    # 3) ê³„ì ˆ / ì‹œê°„ëŒ€ / season_code
    season_str = get_season_from_month(req.target_datetime.month)
    time_range_str = get_time_range_from_hour(req.target_datetime.hour)
    season_code = season_map.get(season_str, -1)

    # 4) XGBoost ì…ë ¥ ë§Œë“¤ê¸° (ë‚ ì”¨ ê¸°ë°˜ ì¹´í…Œê³ ë¦¬ ì˜ˆì¸¡ìš©)
    feature_cols = [
        "temperature",
        "humidity",
        "wind_speed",
        "precipitation",
        "pm25",
        "season_code",
    ]
    raw_features = [
        weather["temperature"],
        weather["humidity"],
        weather["wind_speed"],
        weather["precipitation"],
        weather["pm25"],
        season_code,
    ]
    scaled = scaler.transform([raw_features])
    X_input = pd.DataFrame(scaled, columns=feature_cols)

    # 5) XGBoostê°€ ì˜ˆì¸¡í•œ ì¹´í…Œê³ ë¦¬ (ë‚ ì”¨ ê¸°ë°˜)
    model_cat_id = category_model.predict(X_input)[0]
    model_cat = le_category.inverse_transform([model_cat_id])[0]

    # 6) ë‚ ì”¨ + ë¯¸ì„¸ë¨¼ì§€ ìƒíƒœ í‰ê°€ â†’ ì‹¤ë‚´/ì‹¤ì™¸ ê²°ì •
    temp = weather["temperature"]
    ws = weather["wind_speed"]
    precip = weather["precipitation"]
    pm25 = weather["pm25"]
    pm10 = weather["pm10"]
    pm_grade = classify_pm(pm25, pm10)

    is_rainy = precip > 0.0
    is_windy = ws >= 8.0
    is_too_cold = temp <= 0.0
    is_too_hot = temp >= 30.0
    is_bad_weather = is_rainy or is_windy or is_too_cold or is_too_hot
    is_bad_air = pm_grade in ["ë‚˜ì¨", "ë§¤ìš° ë‚˜ì¨"]

    indoor_required = is_bad_weather or is_bad_air

    # 7) ì„ í˜¸ìš´ë™ ì •ì œ + ì¹´í…Œê³ ë¦¬ ì¡°íšŒ
    fav_list_raw = req.favorites or []
    fav_list = [
        f.strip().replace(",", "")
        for f in fav_list_raw
        if f and f.strip()
    ]
    favorite_set = set(fav_list)

    fav_meta = activity_df[activity_df["activity_name"].isin(fav_list)].copy()
    fav_cats = list(fav_meta["category"].unique())

    reason_parts = []
    if fav_list:
        reason_parts.append(f"ì‚¬ìš©ì ì„ í˜¸ìš´ë™(ì‹¤ì‹œê°„ ì…ë ¥): {fav_list}")
    else:
        reason_parts.append("ì„ í˜¸ìš´ë™ì´ ì „ë‹¬ë˜ì§€ ì•Šì•„, ëª¨ë¸ì´ ì˜ˆì¸¡í•œ ì¹´í…Œê³ ë¦¬ë¥¼ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.")

    # 8) ì¹´í…Œê³ ë¦¬ ì„ íƒ ë¡œì§ (ì„ í˜¸ìš´ë™ + XGBoost + ê°€ì¤‘ì¹˜ ëœë¤)
    if fav_cats:
        if len(fav_cats) == 1:
            # ì„ í˜¸ ì¹´í…Œê³ ë¦¬ê°€ ì‚¬ì‹¤ìƒ í•˜ë‚˜ì¸ ê²½ìš° (ì˜ˆ: ì„ í˜¸ìš´ë™ ì—¬ëŸ¬ ê°œì—¬ë„ ëª¨ë‘ ê±·ê¸° ì¹´í…Œê³ ë¦¬)
            base_cat = fav_cats[0]
            pred_category = base_cat
            reason_parts.append(
                f"ì„ í˜¸ìš´ë™ë“¤ì´ ë™ì¼í•œ ì¹´í…Œê³ ë¦¬ë¡œ ë¬¶ì—¬ ìˆì–´ '{base_cat}' ì¹´í…Œê³ ë¦¬ë¥¼ ê¸°ë³¸ìœ¼ë¡œ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤."
            )
        else:
            # ì—¬ëŸ¬ ì„ í˜¸ ì¹´í…Œê³ ë¦¬ + XGBoost ì˜ˆì¸¡ ì¹´í…Œê³ ë¦¬ë¥¼ ëª¨ë‘ í›„ë³´ë¡œ ë‘ê³  ê°€ì¤‘ì¹˜ ê¸°ë°˜ ë¬´ì‘ìœ„ ì„ íƒ
            cand_cats = sorted(set(fav_cats + [model_cat]))
            weights = []
            for c in cand_cats:
                w = 1.0
                if c in fav_cats:
                    w += 1.0   # ì„ í˜¸ ì¹´í…Œê³ ë¦¬ì´ë©´ ê°€ì¤‘ì¹˜ +1
                if c == model_cat:
                    w += 1.0   # ëª¨ë¸ì´ ì˜ˆì¸¡í•œ ì¹´í…Œê³ ë¦¬ì´ë©´ ê°€ì¤‘ì¹˜ +1
                weights.append(w)
            weights = np.array(weights, dtype=float)
            probs = weights / weights.sum()

            sampled_idx = np.random.choice(len(cand_cats), p=probs)
            pred_category = cand_cats[sampled_idx]

            reason_parts.append(
                f"ì„ í˜¸ìš´ë™ ì¹´í…Œê³ ë¦¬ {fav_cats}ì™€ XGBoost ì˜ˆì¸¡ ì¹´í…Œê³ ë¦¬ '{model_cat}'ë¥¼ ëª¨ë‘ ê³ ë ¤í•˜ì—¬, "
                f"ê°€ì¤‘ì¹˜ ê¸°ë°˜ ë¬´ì‘ìœ„ ì„ íƒìœ¼ë¡œ ìµœì¢… ì¹´í…Œê³ ë¦¬ '{pred_category}'ë¥¼ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤."
            )
    else:
        pred_category = model_cat
        reason_parts.append(
            f"ì„ í˜¸ìš´ë™ì´ í™œë™ ëª©ë¡ê³¼ ë§¤ì¹­ë˜ì§€ ì•Šì•„, XGBoostê°€ ì˜ˆì¸¡í•œ ì¹´í…Œê³ ë¦¬ '{model_cat}' ë¥¼ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤."
        )

    # 9) ì‹¤ë‚´/ì‹¤ì™¸ ìš°ì„  ê·œì¹™ ì„¤ëª…
    if indoor_required:
        reason_parts.append(
            f"ë‚ ì”¨/ëŒ€ê¸° ìƒíƒœê°€ ì¢‹ì§€ ì•Šì•„(ë¹„:{is_rainy}, ê°•í’:{is_windy}, ì¶”ì›€:{is_too_cold}, ë”ì›€:{is_too_hot}, ë¯¸ì„¸ë¨¼ì§€ë“±ê¸‰:{pm_grade}), ì‹¤ë‚´ ìš´ë™ì„ ìš°ì„  ê³ ë ¤í–ˆìŠµë‹ˆë‹¤."
        )
    else:
        reason_parts.append(
            f"ë‚ ì”¨ì™€ ê³µê¸° ì§ˆì´ ë¹„êµì  ì–‘í˜¸í•˜ì—¬, ì‹¤ì™¸ ìš´ë™ì„ ìš°ì„  ê³ ë ¤í–ˆìŠµë‹ˆë‹¤."
        )

    # 10) ìµœì¢… ì¹´í…Œê³ ë¦¬ì— ì†í•˜ëŠ” í›„ë³´ ìš´ë™ë“¤ í•„í„°ë§
    candidates = activity_df[activity_df["category"] == pred_category].copy()

    # ê³„ì ˆ í•„í„°
    cand_season = candidates[
        (candidates["season"].isna())
        | (candidates["season"].astype(str).str.contains(season_str))
    ]
    if not cand_season.empty:
        candidates = cand_season

    # ì‹œê°„ëŒ€ í•„í„°
    cand_time = candidates[
        (candidates["time_range"].isna())
        | (candidates["time_range"].astype(str).str.contains(time_range_str))
    ]
    if not cand_time.empty:
        candidates = cand_time

    # ì‹¤ë‚´/ì‹¤ì™¸ ì¡°ê±´ ì„ í˜¸
    if indoor_required:
        indoor_cands = candidates[
            candidates["location_type"].astype(str).str.contains("ì‹¤ë‚´")
        ]
        if not indoor_cands.empty:
            candidates = indoor_cands
    else:
        outdoor_cands = candidates[
            candidates["location_type"].astype(str).str.contains("ì‹¤ì™¸")
        ]
        if not outdoor_cands.empty:
            candidates = outdoor_cands

    if candidates.empty:
        # í•„í„°ë¡œ ë‹¤ ì‚¬ë¼ì§€ë©´ ì¹´í…Œê³ ë¦¬ë§Œ ë§ëŠ” ì „ì²´ í›„ë³´ë¡œ ë³µêµ¬
        candidates = activity_df[activity_df["category"] == pred_category].copy()

    # 11) ì½˜í…ì¸  ê¸°ë°˜ + GNN ìŠ¤ì½”ì–´ë§ìœ¼ë¡œ ìµœì¢… ìš´ë™ ì„ íƒ (ìµœëŒ€ 3ê°œ í™•ë¥  ìƒ˜í”Œë§)
    fav_match_list: List[str] = []
    user_vec = get_user_embedding_from_favorites(fav_list)

    if not candidates.empty:
        candidates = candidates.copy()
        fav_match_list = list(
            candidates[candidates["activity_name"].isin(fav_list)]["activity_name"].unique()
        )

        # ê° í›„ë³´ë³„ ì ìˆ˜ ê³„ì‚°
        candidates["score"] = candidates.apply(
            lambda row: score_activity(
                row,
                favorite_set=favorite_set,
                indoor_required=indoor_required,
                season_str=season_str,
                time_range_str=time_range_str,
                user_vec=user_vec,
            ),
            axis=1,
        )

        # ì ìˆ˜ ê¸°ì¤€ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
        candidates_sorted = candidates.sort_values("score", ascending=False)

        # ìƒìœ„ 20ê°œê¹Œì§€ë§Œ ìƒ˜í”Œë§ í›„ë³´ë¡œ ì‚¬ìš©
        top_k = min(20, len(candidates_sorted))
        pool = candidates_sorted.iloc[:top_k].copy()

        scores = pool["score"].to_numpy(dtype=float)

        if len(scores) == 0:
            recommended_activities = []
            recommended_activity = None
        else:
            # ì ìˆ˜ â†’ softmax í™•ë¥ 
            if scores.max() != scores.min():
                shifted = scores - scores.max()
                exp_scores = np.exp(shifted)
                probs = exp_scores / exp_scores.sum()
            else:
                probs = np.ones_like(scores) / len(scores)

            # ì¤‘ë³µ ì—†ì´ ìµœëŒ€ 3ê°œ ìƒ˜í”Œë§
            n_rec = min(3, len(pool))
            sampled_idx = np.random.choice(len(pool), size=n_rec, replace=False, p=probs)
            rec_rows = pool.iloc[sampled_idx]

            recommended_activities = list(rec_rows["activity_name"])
            recommended_activity = recommended_activities[0] if recommended_activities else None

        reason_parts.append(
            f"ì½˜í…ì¸  ê¸°ë°˜ + GNN ì„ë² ë”© ì ìˆ˜ì— ë”°ë¼ ìƒìœ„ í›„ë³´ë“¤ ì¤‘ì—ì„œ í™•ë¥ ì ìœ¼ë¡œ ì´ {len(recommended_activities)}ê°œì˜ ìš´ë™ì„ ì¶”ì²œí–ˆìŠµë‹ˆë‹¤."
        )
    else:
        recommended_activities = []
        recommended_activity = None
        reason_parts.append("í•´ë‹¹ ì¡°ê±´ì— ë§ëŠ” ìš´ë™ í›„ë³´ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")

    reason = " / ".join(reason_parts)

    return {
        "ì…ë ¥ê°’": {
            "user_id": req.user_id,
            "location_name": req.location_name,
            "target_datetime": req.target_datetime.isoformat(),
            "favorites_from_request": fav_list,
        },
        "ì§€ì˜¤ì½”ë”©": {"ìœ„ë„": lat, "ê²½ë„": lon},
        "ì‚¬ìš©ëœ_ë‚ ì”¨": {
            "temperature": temp,
            "humidity": weather["humidity"],
            "wind_speed": ws,
            "precipitation": precip,
            "pm25": pm25,
            "pm10": pm10,
            "pm_grade": pm_grade,
            "season": season_str,
            "time_range": time_range_str,
            "owm_dt_txt": weather["raw_dt"],
            "is_rainy": is_rainy,
            "is_windy": is_windy,
            "is_too_cold": is_too_cold,
            "is_too_hot": is_too_hot,
            "is_bad_air": is_bad_air,
        },
        "XGBoost_ì˜ˆì¸¡_ì¹´í…Œê³ ë¦¬": model_cat,
        "ìµœì¢…_ì„ íƒ_ì¹´í…Œê³ ë¦¬": pred_category,
        "ì‹¤ë‚´_ìš°ì„ ì—¬ë¶€": indoor_required,
        "ì¶”ì²œ_ìš´ë™": recommended_activity,           # ëŒ€í‘œ 1ê°œ
        "ì¶”ì²œ_ìš´ë™_ëª©ë¡": recommended_activities,     # ìµœëŒ€ 3ê°œ ë¦¬ìŠ¤íŠ¸
        "ì¶”ì²œ_ê·¼ê±°": reason,
        "ë””ë²„ê·¸": {
            "favorites_raw": fav_list_raw,
            "favorites_clean": fav_list,
            "favorite_categories": fav_cats,
            "favorites_matched_in_category": fav_match_list,
        },
    }