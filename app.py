# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15xUsIc96lG4x4uuG39sa5PhoT7xVnVjz
"""

# -*- coding: utf-8 -*-
"""
app.py — 운동 추천 API (Kakao 지오코딩 + KMA/Open-Meteo + GNN)

- 지오코딩: Kakao Local 주소검색 + 역지오코딩(대한민국 대상)
    * 입력: 상세 도로명주소(예: "경기도 구리시 동구릉로30번길 33")
    * 출력: 카카오맵 기준 위도/경도 + 정규화된 도로명주소

- 날씨: KMA 관측/초단기/단기(1h) 우선 + Open-Meteo(7일/1h)로 5일까지 보충
- 추천: 선호운동이 속한 카테고리들(합집합) 안에서 후보를 뽑고
        GNN 가중 / 실내·실외 정책 / 랜덤 샘플로 운동 3개 추천
"""

from fastapi import FastAPI, HTTPException, Body
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime, timedelta, timezone
import os, re, random
import requests
import pandas as pd
import numpy as np
import joblib

# -------- optional: .env --------
try:
    from dotenv import load_dotenv
    load_dotenv()
except Exception:
    pass

# -------- optional: torch (GNN) --------
try:
    import torch
    TORCH_AVAILABLE = True
except Exception as e:
    TORCH_AVAILABLE = False
    print("torch import 실패. GNN 임베딩 비활성화:", e)

# =========================
# FastAPI
# =========================
app = FastAPI(
    title="운동 추천 API (Kakao 지오코딩 + KMA/Open-Meteo + GNN)",
    version="4.1.0-kakao-only-pref-based",
)

# =========================
# Kakao Local API (지오코딩 전용)
# =========================
# .env에 KAKAO_REST_API_KEY를 넣어두고 사용하는 걸 추천
KAKAO_REST_API_KEY = os.getenv("KAKAO_REST_API_KEY", "e171de783420e9199d7edc58d475ffd2")
KAKAO_ADDRESS_URL   = "https://dapi.kakao.com/v2/local/search/address.json"
KAKAO_COORD2ADDR_URL = "https://dapi.kakao.com/v2/local/geo/coord2address.json"

# =========================
# OWM (미세먼지용)
# =========================
OWM_API_KEY = os.getenv("OWM_API_KEY", "9f8737894290204a7b2793f510443e46")

# =========================
# KMA (관측/초단기/단기)
# =========================
KMA_API_KEY         = os.getenv("KMA_API_KEY", "e44a573223f2660f6169de6e9c31658a456d562ea2e1d84e4cc717baca25950a")
KMA_ULTRA_NCST_URL  = "http://apis.data.go.kr/1360000/VilageFcstInfoService_2.0/getUltraSrtNcst"
KMA_ULTRA_FCST_URL  = "http://apis.data.go.kr/1360000/VilageFcstInfoService_2.0/getUltraSrtFcst"
KMA_VILAGE_FCST_URL = "http://apis.data.go.kr/1360000/VilageFcstInfoService_2.0/getVilageFcst"

# Open-Meteo (무료, 7일 1시간)
OPEN_METEO_URL = "https://api.open-meteo.com/v1/forecast"

# =========================
# 모델/스케일러/라벨인코더
# =========================
category_model = joblib.load("category_model.pkl")
scaler         = joblib.load("feature_scaler.pkl")  # temp, hum, ws, precip, pm25, pm10
le_category    = joblib.load("category_label_encoder.pkl")

# =========================
# 활동 메타데이터 (activity_information.csv)
# =========================
activity_df = pd.read_csv("activity_information.csv")
activity_df = activity_df.rename(columns={
    "활동명": "activity_name",
    "활동카테고리": "category",
    "장소유형": "indoor_outdoor",
    "난이도": "difficulty",
    "추천계절": "season",
    "적합시간대": "time_range",
})
for col in ["season", "time_range", "indoor_outdoor"]:
    if col not in activity_df.columns:
        activity_df[col] = np.nan

# =========================
# GNN 임베딩(옵션)
# =========================
if TORCH_AVAILABLE:
    try:
        gnn_obj = torch.load("activity_gnn_embeddings.pt", map_location="cpu")
        ACT_EMB = gnn_obj.get("activity_embeddings", None)
        ACT2IDX = gnn_obj.get("act2idx", {})
        if ACT_EMB is not None:
            ACT_EMB = torch.nn.functional.normalize(ACT_EMB, dim=1)
            print("GNN activity embeddings loaded.")
        else:
            print("GNN embeddings에 activity_embeddings 없음.")
    except Exception as e:
        ACT_EMB, ACT2IDX = None, {}
        print("GNN embeddings not loaded:", e)
else:
    ACT_EMB, ACT2IDX = None, {}
    print("torch 없음 → GNN 미사용.")

def build_user_embedding_from_favorites(favorite_list: List[str]):
    if ACT_EMB is None or not favorite_list:
        return None
    idx_list = [ACT2IDX.get(n) for n in favorite_list if ACT2IDX.get(n) is not None]
    if not idx_list:
        return None
    vecs = ACT_EMB[idx_list]
    return vecs.mean(dim=0)

def gnn_similarity_score(user_vec, activity_name: str) -> float:
    if user_vec is None or ACT_EMB is None:
        return 0.0
    idx = ACT2IDX.get(activity_name)
    if idx is None:
        return 0.0
    act_vec = ACT_EMB[idx]
    sim = torch.nn.functional.cosine_similarity(user_vec.unsqueeze(0), act_vec.unsqueeze(0))
    return float(sim.item())

# =========================
# 요청/응답 모델
# =========================
class LocationUserRequest(BaseModel):
    user_id: str
    location_name: str          # 상세 도로명주소 (대한민국)
    target_datetime: datetime
    favorites: Optional[List[str]] = None

# =========================
# 유틸: 계절/시간대/미세먼지 등급
# =========================
def get_season_from_month(m: int) -> str:
    if m in (3, 4, 5):  return "봄"
    if m in (6, 7, 8):  return "여름"
    if m in (9, 10, 11): return "가을"
    return "겨울"

def get_time_range_from_hour(h: int) -> str:
    if 6 <= h < 12:   return "오전"
    if 12 <= h < 18:  return "오후"
    if 18 <= h < 24:  return "저녁"
    return "새벽"

def classify_pm_grade(pm25: float, pm10: float) -> str:
    # 매우 단순 등급 (둘 중 더 나쁜 쪽 기준)
    def grade_pm25(x):
        if x <= 15:  return "좋음"
        if x <= 35:  return "보통"
        if x <= 75:  return "나쁨"
        return "매우 나쁨"
    def grade_pm10(x):
        if x <= 30:  return "좋음"
        if x <= 80:  return "보통"
        if x <= 150: return "나쁨"
        return "매우 나쁨"
    g1 = grade_pm25(pm25)
    g2 = grade_pm10(pm10)
    order = ["좋음", "보통", "나쁨", "매우 나쁨"]
    return g1 if order.index(g1) >= order.index(g2) else g2

# =========================
# Kakao 지오코딩 (대한민국 전용, 엄격 모드)
# =========================
def geocode_kakao_strict(query: str):
    """
    - 입력: 대한민국 상세 도로명주소(또는 일반 주소 문자열)
    - 동작:
        1) Kakao 주소검색(query) 호출
        2) 도로명 주소(ROAD_ADDR)를 우선 후보로 사용
        3) 각 후보에 대해:
            - 좌표(y, x)를 역지오코딩(coord2address)에 넣고
            - forward 주소와 reverse 주소의 address_name이
              공백 무시하고 완전히 일치하면 엄격 매칭 성공
        4) 그런 후보가 하나도 없으면:
            - 도로명 주소 후보들 중 첫 번째를 사용 (완화)
            - 그것도 없으면 전체 후보 중 첫 번째 사용
    - 반환: (lat, lon, geo_source, normalized_address, level2_region)
    """
    if not KAKAO_REST_API_KEY:
        raise HTTPException(status_code=500, detail="Kakao REST API 키가 설정되지 않았습니다.")

    headers = {"Authorization": "KakaoAK " + KAKAO_REST_API_KEY}

    # 1) 주소검색
    r = requests.get(
        KAKAO_ADDRESS_URL,
        headers=headers,
        params={"query": query, "size": 10},
        timeout=7,
    )
    if r.status_code in (401, 403):
        raise HTTPException(status_code=500, detail=f"Kakao 인증 실패 (HTTP {r.status_code})")
    r.raise_for_status()
    data = r.json()
    docs = data.get("documents", [])
    if not docs:
        raise HTTPException(status_code=400, detail=f"Kakao 주소검색 결과 없음: {query}")

    # 도로명 주소 우선
    road_docs = [d for d in docs if d.get("address_type") == "ROAD_ADDR"]
    candidates = road_docs if road_docs else docs

    def normalize_addr_str(s: str) -> str:
        return re.sub(r"\s+", "", s.strip())

    best = None
    # 2) 역지오코딩으로 엄격 매칭 시도
    for d in candidates:
        x = float(d["x"])
        y = float(d["y"])
        addr_name_fwd = d.get("address_name") or d.get("road_address") or ""
        addr_name_fwd = addr_name_fwd if isinstance(addr_name_fwd, str) else ""

        try:
            r2 = requests.get(
                KAKAO_COORD2ADDR_URL,
                headers=headers,
                params={"x": x, "y": y},
                timeout=7,
            )
            r2.raise_for_status()
            data2 = r2.json()
            addr2 = (data2.get("documents") or [{}])[0].get("road_address") or {}
            addr_name_rev = addr2.get("address_name", "") or ""
        except Exception:
            addr_name_rev = ""

        if normalize_addr_str(addr_name_fwd) and \
           normalize_addr_str(addr_name_fwd) == normalize_addr_str(addr_name_rev):
            best = (d, addr_name_rev)
            break

    if best is None:
        # 엄격 매칭 실패 → 후보 중 첫 번째 사용
        d = candidates[0]
        addr_name = d.get("address_name") or d.get("road_address") or ""
        addr_name = addr_name if isinstance(addr_name, str) else ""
    else:
        d, addr_name = best

    lat = float(d["y"])
    lon = float(d["x"])

    # 행정구 2단계(구/시 등)
    region_2depth = ""
    road_addr = d.get("road_address")
    if isinstance(road_addr, dict):
        region_2depth = road_addr.get("region_2depth_name", "") or ""
        if not addr_name:
            addr_name = road_addr.get("address_name", "") or ""

    normalized_address = addr_name or query
    return lat, lon, "kakao_strict", normalized_address, region_2depth

def geocode_location(location_name: str):
    try:
        return geocode_kakao_strict(location_name)
    except HTTPException:
        raise
    except Exception as e:
        print("geocode_location 실패:", e)
        raise HTTPException(status_code=500, detail="지오코딩 실패")

# =========================
# KMA 좌표 변환 (DFS -> lat/lon)
# =========================
def latlon_to_kma_xy(lat: float, lon: float):
    RE   = 6371.00877  # 지구 반경(km)
    GRID = 5.0         # 격자 간격(km)
    SLAT1 = 30.0
    SLAT2 = 60.0
    OLON  = 126.0
    OLAT  = 38.0
    XO    = 43
    YO    = 136

    DEGRAD = np.pi / 180.0
    re = RE / GRID
    slat1 = SLAT1 * DEGRAD
    slat2 = SLAT2 * DEGRAD
    olon  = OLON  * DEGRAD
    olat  = OLAT  * DEGRAD

    sn = np.tan(np.pi * 0.25 + slat2 * 0.5) / np.tan(np.pi * 0.25 + slat1 * 0.5)
    sn = np.log(np.cos(slat1) / np.cos(slat2)) / np.log(sn)
    sf = np.tan(np.pi * 0.25 + slat1 * 0.5)
    sf = (sf ** sn) * (np.cos(slat1) / sn)
    ro = np.tan(np.pi * 0.25 + olat * 0.5)
    ro = re * sf / (ro ** sn)
    ra = np.tan(np.pi * 0.25 + lat * DEGRAD * 0.5)
    ra = re * sf / (ra ** sn)
    theta = lon * DEGRAD - olon
    if theta > np.pi:
        theta -= 2.0 * np.pi
    if theta < -np.pi:
        theta += 2.0 * np.pi
    theta *= sn
    x = (ra * np.sin(theta)) + XO
    y = (ro - ra * np.cos(theta)) + YO
    return int(x + 0.5), int(y + 0.5)

def _kma_base_datetime(kst_dt: datetime):
    base = kst_dt.replace(minute=0, second=0, microsecond=0)
    if kst_dt.minute < 40:
        base -= timedelta(hours=1)
    return base.strftime("%Y%m%d"), base.strftime("%H%M")

def _kma_call(url, params):
    """KMA 공통 호출 함수
    - 타임아웃, 429(Too Many Requests) 등 오류 발생 시 예외를 밖으로 올리지 않고 빈 리스트 반환
    - 상위 로직에서는 "데이터 없음"으로만 취급하고 서버는 500이 나지 않도록 함
    """
    try:
        r = requests.get(url, params=params, timeout=12)
        if r.status_code == 429:
            print(f"[KMA] 429 Too Many Requests: url={url}, params={params}")
            return []
        r.raise_for_status()
        data = r.json()
        return data.get("response", {}).get("body", {}).get("items", {}).get("item", [])
    except requests.exceptions.Timeout:
        print(f"[KMA] Timeout: url={url}, params={params}")
        return []
    except requests.exceptions.RequestException as e:
        print(f"[KMA] RequestException: {e} (url={url}, params={params})")
        return []

def _build_kst(dt: datetime) -> datetime:
    KST = timezone(timedelta(hours=9))
    return dt.astimezone(KST) if dt.tzinfo else dt.replace(tzinfo=KST)

# =========================
# KMA: 관측/예보 수집
# =========================
def get_kma_nowcast(lat: float, lon: float, ref_dt: datetime):
    if not KMA_API_KEY:
        return []
    KST_dt = _build_kst(ref_dt)
    base_date, base_time = _kma_base_datetime(KST_dt)
    nx, ny = latlon_to_kma_xy(lat, lon)
    params = {
        "serviceKey": KMA_API_KEY,
        "numOfRows": 100,
        "pageNo": 1,
        "dataType": "JSON",
        "base_date": base_date,
        "base_time": base_time,
        "nx": nx,
        "ny": ny,
    }
    items = _kma_call(KMA_ULTRA_NCST_URL, params)
    row = {}
    for it in items:
        cat = it.get("category")
        val = it.get("obsrValue")
        row[cat] = val
    out = []
    try:
        t = int(round(float(row.get("T1H"))))
        h = int(round(float(row.get("REH"))))
        w = float(row.get("WSD", 0.0))
    except Exception:
        return []
    p_raw = row.get("RN1", "0")
    try:
        p = 0.0 if "강수없음" in str(p_raw) else float(str(p_raw).replace("mm", "").strip())
    except Exception:
        p = 0.0
    ts = KST_dt.replace(minute=0, second=0, microsecond=0)
    out.append(
        {
            "dt": ts,
            "temperature": t,
            "humidity": h,
            "wind_speed": w,
            "precipitation": p,
            "src": "kma_nowcast",
        }
    )
    return out

def get_kma_ultra_fcst(lat: float, lon: float, ref_dt: datetime):
    if not KMA_API_KEY:
        return []
    KST_dt = _build_kst(ref_dt)
    base_date, base_time = _kma_base_datetime(KST_dt)
    nx, ny = latlon_to_kma_xy(lat, lon)
    params = {
        "serviceKey": KMA_API_KEY,
        "numOfRows": 200,
        "pageNo": 1,
        "dataType": "JSON",
        "base_date": base_date,
        "base_time": base_time,
        "nx": nx,
        "ny": ny,
    }
    items = _kma_call(KMA_ULTRA_FCST_URL, params)
    slots = {}
    for it in items:
        fd, ft = it.get("fcstDate"), it.get("fcstTime")
        key = f"{fd}{ft}"
        if key not in slots:
            slots[key] = {}
        slots[key][it.get("category")] = it.get("fcstValue")
    out = []
    for key, vals in slots.items():
        y, m, d = int(key[:4]), int(key[4:6]), int(key[6:8])
        hh, mm = int(key[8:10]), int(key[10:12])
        ts = datetime(y, m, d, hh, mm, tzinfo=timezone(timedelta(hours=9)))
        try:
            t = int(round(float(vals["T1H"])))
            h = int(round(float(vals["REH"])))
            w = float(vals.get("WSD", 0.0))
        except Exception:
            continue
        p_raw = vals.get("RN1", "0")
        try:
            p = 0.0 if "강수없음" in str(p_raw) else float(str(p_raw).replace("mm", "").strip())
        except Exception:
            p = 0.0
        out.append(
            {
                "dt": ts,
                "temperature": t,
                "humidity": h,
                "wind_speed": w,
                "precipitation": p,
                "src": "kma_ultra_fcst",
            }
        )
    return out

def get_kma_vilage_fcst(lat: float, lon: float, ref_dt: datetime, hours: int = 72):
    if not KMA_API_KEY:
        return []
    KST_dt = _build_kst(ref_dt)
    base_date, base_time = _kma_base_datetime(KST_dt)
    nx, ny = latlon_to_kma_xy(lat, lon)
    params = {
        "serviceKey": KMA_API_KEY,
        "numOfRows": 500,
        "pageNo": 1,
        "dataType": "JSON",
        "base_date": base_date,
        "base_time": base_time,
        "nx": nx,
        "ny": ny,
    }
    items = _kma_call(KMA_VILAGE_FCST_URL, params)
    slots = {}
    for it in items:
        fd, ft = it.get("fcstDate"), it.get("fcstTime")
        key = f"{fd}{ft}"
        if key not in slots:
            slots[key] = {}
        slots[key][it.get("category")] = it.get("fcstValue")
    out = []
    for key, vals in slots.items():
        y, m, d = int(key[:4]), int(key[4:6]), int(key[6:8])
        hh, mm = int(key[8:10]), int(key[10:12])
        ts = datetime(y, m, d, hh, mm, tzinfo=timezone(timedelta(hours=9)))
        try:
            t = int(round(float(vals["TMP"])))
            h = int(round(float(vals["REH"])))
            w = float(vals.get("WSD", 0.0))
        except Exception:
            continue
        p_raw = vals.get("PCP", "0")
        try:
            p = 0.0 if "강수없음" in str(p_raw) else float(str(p_raw).replace("mm", "").strip())
        except Exception:
            p = 0.0
        out.append(
            {
                "dt": ts,
                "temperature": t,
                "humidity": h,
                "wind_speed": w,
                "precipitation": p,
                "src": "kma_vilage_fcst",
            }
        )
    out.sort(key=lambda x: x["dt"])
    end_cut = _build_kst(ref_dt) + timedelta(hours=hours)
    out = [x for x in out if x["dt"] <= end_cut]
    return out

# =========================
# Open-Meteo 7일/1시간
# =========================
def get_open_meteo_hourly(lat: float, lon: float, start_dt: datetime, hours: int = 120):
    """Open-Meteo 시간별 예보 조회
    - 장애/타임아웃 발생 시 빈 리스트를 반환하여 서버가 500으로 죽지 않게 함
    """
    params = {
        "latitude": lat,
        "longitude": lon,
        "hourly": "temperature_2m,relative_humidity_2m,wind_speed_10m,precipitation",
        "timezone": "Asia/Seoul",
        "forecast_days": 7,
    }
    try:
        r = requests.get(OPEN_METEO_URL, params=params, timeout=12)
        r.raise_for_status()
        data = r.json()
    except requests.exceptions.RequestException as e:
        print(f"[OpenMeteo] RequestException: {e} (params={params})")
        return []

    hr = data.get("hourly", {})
    times = hr.get("time", [])
    temp = hr.get("temperature_2m", [])
    hum  = hr.get("relative_humidity_2m", [])
    wind = hr.get("wind_speed_10m", [])
    pcp  = hr.get("precipitation", [])
    series = []
    for i in range(min(len(times), len(temp), len(hum), len(wind), len(pcp))):
        ts = pd.to_datetime(times[i]).to_pydatetime().replace(tzinfo=timezone(timedelta(hours=9)))
        series.append(
            {
                "dt": ts,
                "temperature": int(round(float(temp[i]))),
                "humidity": int(round(float(hum[i]))),
                "wind_speed": float(wind[i]),
                "precipitation": float(pcp[i]),
                "src": "open_meteo",
            }
        )
    series.sort(key=lambda x: x["dt"])
    KST_start = _build_kst(start_dt).replace(minute=0, second=0, microsecond=0)
    end = KST_start + timedelta(hours=hours)
    series = [x for x in series if KST_start <= x["dt"] <= end]
    return series

# =========================
# 5일(120h) 1시간 타임라인 빌드
# =========================
def build_5day_hourly_series(lat: float, lon: float, start_dt: datetime):
    KST_start = _build_kst(start_dt).replace(minute=0, second=0, microsecond=0)
    KST_end   = KST_start + timedelta(hours=120)
    timeline = []
    timeline += get_kma_nowcast(lat, lon, KST_start)
    timeline += get_kma_ultra_fcst(lat, lon, KST_start)
    timeline += get_kma_vilage_fcst(lat, lon, KST_start, hours=72)
    om = get_open_meteo_hourly(lat, lon, KST_start, hours=120)

    if om:
        pri = {"kma_nowcast": 4, "kma_ultra_fcst": 3, "kma_vilage_fcst": 2, "open_meteo": 1}
        bucket = {}
        for x in timeline + om:
            k = x["dt"]
            if KST_start <= k <= KST_end:
                if (k not in bucket) or (pri.get(x["src"], 0) > pri.get(bucket[k]["src"], 0)):
                    bucket[k] = x
        merged = [bucket[k] for k in sorted(bucket.keys())]
    else:
        merged = [x for x in timeline if KST_start <= x["dt"] <= KST_end]

    for x in merged:
        x["season"] = get_season_from_month(_build_kst(x["dt"]).month)
        x["time_range"] = get_time_range_from_hour(_build_kst(x["dt"]).hour)
    return merged

def get_weather_at_datetime(lat: float, lon: float, target_dt: datetime):
    """특정 시각(target_dt)의 대표 날씨를 반환
    - KMA + Open-Meteo 모두 실패해도 서버가 죽지 않도록 기본값으로 대체
    """
    series = build_5day_hourly_series(lat, lon, target_dt)
    tgt = _build_kst(target_dt).replace(minute=0, second=0, microsecond=0)

    if not series:
        # 모든 외부 날씨 API 실패 시 → 기본값 사용
        print("[Weather] 시계열 생성 실패 -> 기본 날씨값 사용")
        season = get_season_from_month(tgt.month)
        time_range = get_time_range_from_hour(tgt.hour)
        return {
            "dt": tgt,
            "temperature": 20,
            "humidity": 50,
            "wind_speed": 1.0,
            "precipitation": 0.0,
            "src": "fallback",
            "season": season,
            "time_range": time_range,
        }

    for x in series:
        if x["dt"] == tgt:
            return x
    best = min(series, key=lambda x: abs(x["dt"] - tgt))
    return best

# =========================
# 미세먼지(간단: OWM 공기질)
# =========================
def get_air_quality(lat: float, lon: float):
    try:
        r = requests.get(
            "http://api.openweathermap.org/data/2.5/air_pollution",
            params={"lat": lat, "lon": lon, "appid": OWM_API_KEY},
            timeout=10,
        )
        r.raise_for_status()
        data = r.json()
        comp = (data.get("list") or [{}])[0].get("components", {})
        pm25 = float(comp.get("pm2_5", 0.0))
        pm10 = float(comp.get("pm10", 0.0))
    except Exception:
        pm25, pm10 = 0.0, 0.0
    return pm25, pm10, classify_pm_grade(pm25, pm10)

# =========================
# 스케일러 입력 벡터(6개)
# =========================
def build_feature_vector(weather: dict) -> np.ndarray:
    x = np.array(
        [[
            weather["temperature"],
            weather["humidity"],
            weather["wind_speed"],
            weather["precipitation"],
            weather["pm25"],
            weather["pm10"],
        ]],
        dtype=float,
    )
    return scaler.transform(x)

# =========================
# 추천 엔드포인트 (선호 카테고리 합집합 기반)
# =========================
@app.post("/recommend/by-location-and-user")
def recommend_by_location_and_user(
    req: LocationUserRequest = Body(
        ...,
        example={
            "user_id": "demoUser",
            "location_name": "서울특별시 강남구",
            "target_datetime": "2025-11-07T09:00:00",
            "favorites": ["걷기", "배드민턴"],
        },
    )
):
    # 1) 지오코딩 (대한민국 Kakao)
    lat, lon, geo_source, normalized_addr, addr_level = geocode_location(req.location_name)

    # 2) 타겟 시각 날씨(정시)
    w = get_weather_at_datetime(lat, lon, req.target_datetime)
    pm25, pm10, pm_grade = get_air_quality(lat, lon)
    w["pm25"], w["pm10"], w["pm_grade"] = pm25, pm10, pm_grade

    is_rainy    = float(w["precipitation"]) > 0.1
    is_windy    = float(w["wind_speed"])   >= 7.0
    is_too_cold = int(w["temperature"])    <= 0
    is_too_hot  = int(w["temperature"])    >= 30
    is_bad_air  = pm_grade in ["나쁨", "매우 나쁨"]
    indoor_required = is_rainy or is_windy or is_too_cold or is_too_hot or is_bad_air

    # 3) 카테고리 예측 (XGBoost)
    weather_for_model = {
        "temperature": int(w["temperature"]),
        "humidity": int(w["humidity"]),
        "wind_speed": float(w["wind_speed"]),
        "precipitation": float(w["precipitation"]),
        "pm25": float(pm25),
        "pm10": float(pm10),
    }
    X_scaled = build_feature_vector(weather_for_model)
    cat_idx  = category_model.predict(X_scaled)[0]
    pred_category = le_category.inverse_transform([cat_idx])[0]

    # 4) 선호 카테고리 기반으로 추천 범위 결정
    fav_list_raw = req.favorites or []
    fav_list = [f.strip().replace(",", "") for f in fav_list_raw if f and f.strip()]
    fav_meta = activity_df[activity_df["activity_name"].isin(fav_list)]
    fav_cats = list(fav_meta["category"].dropna().unique())

    reason_parts = []
    if fav_list:
        reason_parts.append(f"사용자 선호운동(입력): {fav_list}")

    # base_categories = 실제 추천에 사용할 카테고리 집합
    if not fav_cats:
        base_categories = [pred_category]
        reason_parts.append(f"선호 카테고리 없음 → 모델 예측 '{pred_category}' 사용")
    elif len(fav_cats) == 1:
        base_categories = fav_cats
        reason_parts.append(
            f"선호 카테고리 '{fav_cats[0]}' 우선 사용 (모델 예측 '{pred_category}'는 참고)"
        )
    else:
        base_categories = fav_cats
        reason_parts.append(
            f"여러 선호 카테고리 {fav_cats}에서 추천 (모델 예측 '{pred_category}'는 참고)"
        )

    if indoor_required:
        reason_parts.append("날씨·미세먼지 상태 상 실내 운동 권장")
        candidates = activity_df[activity_df["indoor_outdoor"] == "실내"].copy()
        if not candidates.empty:
            tmp = candidates[candidates["category"].isin(base_categories)]
            if not tmp.empty:
                candidates = tmp
    else:
        candidates = activity_df[activity_df["category"].isin(base_categories)].copy()

    if candidates.empty:
        candidates = activity_df[activity_df["category"].isin(base_categories)].copy()

    # 6) 점수 + 랜덤 샘플(상위 10개 내에서 3개 무작위)
    favorite_set = set(fav_list)
    user_vec = build_user_embedding_from_favorites(fav_list)

    scored = []
    for _, row in candidates.iterrows():
        act = row["activity_name"]
        s = 3.0
        if act in favorite_set:
            s += 2.0
        s += gnn_similarity_score(user_vec, act) if user_vec is not None else 0.0
        if indoor_required and row["indoor_outdoor"] == "실외":
            s -= 2.0
        scored.append((act, s))

    scored.sort(key=lambda x: x[1], reverse=True)
    pool = scored[: min(10, len(scored))]
    rng = random.Random()
    rng.seed(os.urandom(16))
    rng.shuffle(pool)
    top = pool[: min(3, len(pool))]

    recommended_activity   = top[0][0] if top else None
    recommended_activities = [a for a, _ in top]

    reason = " / ".join(reason_parts)
    weather_info = {
        "temperature": w["temperature"],
        "humidity": w["humidity"],
        "wind_speed": w["wind_speed"],
        "precipitation": w["precipitation"],
        "pm25": pm25,
        "pm10": pm10,
        "pm_grade": pm_grade,
        "season": w.get("season"),
        "time_range": w.get("time_range"),
        "source": w.get("src"),
    }

    return {
        "input": {
            "user_id": req.user_id,
            "raw_location_name": req.location_name,
            "normalized_address": normalized_addr,
            "addr_level2": addr_level,
            "target_datetime": _build_kst(req.target_datetime).isoformat(),
            "favorites_from_request": fav_list_raw,
        },
        "지오코딩": {"위도": lat, "경도": lon},
        "지오코딩_출처": geo_source,
        "사용된_날씨": weather_info,
        "XGBoost_예측_카테고리": pred_category,
        "최종_선택_카테고리": base_categories,
        "실내_우선여부": indoor_required,
        "추천_운동": recommended_activity,
        "추천_운동_목록": recommended_activities,
        "추천_근거": reason,
    }

# =========================
# 5일(120h) 예보만 반환(검증용)
# =========================
@app.get("/debug/weather-timeline")
def debug_weather_timeline(location_name: str, start_datetime: datetime):
    lat, lon, geo_source, normalized_addr, addr_level = geocode_location(location_name)
    series = build_5day_hourly_series(lat, lon, start_datetime)
    return {
        "location_name": location_name,
        "normalized_address": normalized_addr,
        "geo_source": geo_source,
        "lat": lat,
        "lon": lon,
        "start": _build_kst(start_datetime).isoformat(),
        "길이(시간)": len(series),
        "시계열": [
            {
                "dt": _build_kst(x["dt"]).isoformat(),
                "temperature": int(x["temperature"]),
                "humidity": int(x["humidity"]),
                "wind_speed": float(x["wind_speed"]),
                "precipitation": float(x["precipitation"]),
                "season": x["season"],
                "time_range": x["time_range"],
                "source": x["src"],
            }
            for x in series
        ],
    }
