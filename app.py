# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15xUsIc96lG4x4uuG39sa5PhoT7xVnVjz
"""

# app.py

from fastapi import FastAPI
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime
import requests
import pandas as pd
import joblib

# =========================
# ğŸ”§ ì„¤ì • â€“ OpenWeatherMap
# =========================
OWM_API_KEY = "9f8737894290204a7b2793f510443e46"  # ğŸ‘‰ ì—¬ê¸° ë³¸ì¸ API í‚¤ ë„£ê¸°
OWM_GEOCODE_URL = "http://api.openweathermap.org/geo/1.0/direct"
OWM_FORECAST_URL = "https://api.openweathermap.org/data/2.5/forecast"       # 5ì¼ / 3ì‹œê°„ ì˜ˆë³´
OWM_AIR_URL = "http://api.openweathermap.org/data/2.5/air_pollution"        # í˜„ì¬ ëŒ€ê¸°ì§ˆ

# =========================
# ğŸ¯ í•™ìŠµëœ ëª¨ë¸/ìŠ¤ì¼€ì¼ëŸ¬/ì¸ì½”ë” ë¡œë“œ
# =========================
category_model = joblib.load("category_model.pkl")
scaler = joblib.load("feature_scaler.pkl")
le_category = joblib.load("category_label_encoder.pkl")

# =========================
# ğŸ“‚ CSV ë¡œë“œ (ìš´ë™ ë©”íƒ€ë°ì´í„°)
# =========================
activity_df = pd.read_csv("activity_information.csv")
activity_df = activity_df.rename(
    columns={
        "í™œë™ëª…": "activity_name",
        "í™œë™ì¹´í…Œê³ ë¦¬": "category",
        "ì¥ì†Œìœ í˜•": "location_type",
        "ë‚œì´ë„": "difficulty",
        "ì¶”ì²œê³„ì ˆ": "season",
        "ì í•©ì‹œê°„ëŒ€": "time_range",
    }
)

season_map = {"ë´„": 0, "ì—¬ë¦„": 1, "ê°€ì„": 2, "ê²¨ìš¸": 3}

# =========================
# ğŸ§© Pydantic ìš”ì²­ ìŠ¤í‚¤ë§ˆ
# =========================
class LocationUserRequest(BaseModel):
    user_id: str
    location_name: str
    target_datetime: datetime
    favorites: Optional[List[str]] = None  # âœ… UIì—ì„œ ì‹¤ì‹œê°„ìœ¼ë¡œ ë°›ì€ ì„ í˜¸ìš´ë™ ë¦¬ìŠ¤íŠ¸


# =========================
# ğŸ”§ ê³„ì ˆ / ì‹œê°„ëŒ€ ìœ í‹¸
# =========================
def get_season_from_month(m: int) -> str:
    if 3 <= m <= 5:
        return "ë´„"
    if 6 <= m <= 8:
        return "ì—¬ë¦„"
    if 9 <= m <= 11:
        return "ê°€ì„"
    return "ê²¨ìš¸"


def get_time_range_from_hour(h: int) -> str:
    if 5 <= h < 12:
        return "ì˜¤ì „"
    if 12 <= h < 18:
        return "ì˜¤í›„"
    if 18 <= h < 23:
        return "ì €ë…"
    return "ì•¼ê°„"


def classify_pm(pm25: float, pm10: float) -> str:
    # ê°„ë‹¨ í•œêµ­ í™˜ê²½ ê¸°ì¤€ ê·¼ì‚¬ ë²„ì „
    if pm25 <= 15 and pm10 <= 30:
        return "ì¢‹ìŒ"
    if pm25 <= 35 and pm10 <= 80:
        return "ë³´í†µ"
    if pm25 <= 75 and pm10 <= 150:
        return "ë‚˜ì¨"
    return "ë§¤ìš° ë‚˜ì¨"


# =========================
# ğŸŒ Geocoding â€“ OpenWeatherMap + Fallback
# =========================
def geocode_owm(location_name: str):
    """
    OpenWeatherMap Geocoding.
    - 1ì°¨: ê·¸ëŒ€ë¡œ location_nameìœ¼ë¡œ ê²€ìƒ‰
    - 2ì°¨: ",KR" ë¶™ì—¬ì„œ ê²€ìƒ‰
    - 3ì°¨: 'ì„±ë‚¨ì‹œ ìˆ˜ì •êµ¬' â†’ 'ì„±ë‚¨ì‹œ' ê°™ì€ ë„ì‹œ ë‹¨ìœ„ë¡œ ì¶•ì•½í•´ì„œ ì¬ì‹œë„
    """

    def call_geocode(q: str):
        params = {
            "q": q,
            "limit": 1,
            "appid": OWM_API_KEY,
        }
        r = requests.get(OWM_GEOCODE_URL, params=params)
        r.raise_for_status()
        return r.json()

    queries = []

    # 1) ì›ë³¸ ê·¸ëŒ€ë¡œ
    queries.append(location_name)
    queries.append(f"{location_name},KR")

    # 2) 'ì„±ë‚¨ì‹œ ìˆ˜ì •êµ¬' â†’ 'ì„±ë‚¨ì‹œ' ê°™ì€ í˜•íƒœë¡œ ì¶•ì•½
    tokens = location_name.split()
    if tokens:
        city_token = None
        for t in tokens:
            if t.endswith("ì‹œ"):
                city_token = t
                break
        if city_token is None:
            city_token = tokens[0]

        queries.append(city_token)
        queries.append(f"{city_token},KR")

    # ì‹¤ì œ í˜¸ì¶œ ì‹œë„
    for q in queries:
        try:
            data = call_geocode(q)
        except Exception:
            continue

        if data:
            lat = float(data[0]["lat"])
            lon = float(data[0]["lon"])
            return lat, lon

    # ì „ë¶€ ì‹¤íŒ¨í•˜ë©´ ì—ëŸ¬
    raise ValueError(
        f"'{location_name}' ì— ëŒ€í•œ ì¢Œí‘œë¥¼ OpenWeatherMapì—ì„œ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. "
        f"ë„ì‹œ ì´ë¦„ë§Œ(ì˜ˆ: 'ì„±ë‚¨ì‹œ' ë˜ëŠ” 'Seongnam-si')ìœ¼ë¡œ ë‹¤ì‹œ ì‹œë„í•´ ë³´ì„¸ìš”."
    )


# =========================
# ğŸŒ¦ OpenWeather 5ì¼ ì˜ˆë³´ + 1ì‹œê°„ ê°„ê²© ë³´ê°„ + Air Pollution
# =========================
def get_weather_from_owm(lat: float, lon: float, target_dt: datetime):
    # 1) 5ì¼ / 3ì‹œê°„ ì˜ˆë³´
    params = {
        "lat": lat,
        "lon": lon,
        "appid": OWM_API_KEY,
        "units": "metric",
        "lang": "kr",
    }
    r = requests.get(OWM_FORECAST_URL, params=params)
    r.raise_for_status()
    data = r.json()

    items = data.get("list", [])
    if not items:
        raise RuntimeError("OpenWeather 5ì¼ ì˜ˆë³´ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")

    rows = []
    for it in items:
        dt_txt = it.get("dt_txt")
        if not dt_txt:
            continue

        main = it.get("main", {})
        wind = it.get("wind", {})
        rain = it.get("rain", {})

        temp = main.get("temp")
        hum = main.get("humidity")
        ws = wind.get("speed", 0.0)
        precip = rain.get("3h", 0.0) or 0.0

        rows.append(
            {
                "dt": pd.to_datetime(dt_txt),
                "temperature": float(temp) if temp is not None else None,
                "humidity": float(hum) if hum is not None else None,
                "wind_speed": float(ws),
                "precipitation": float(precip),
            }
        )

    df = pd.DataFrame(rows).set_index("dt").sort_index()

    # âœ… 3ì‹œê°„ â†’ 1ì‹œê°„ìœ¼ë¡œ resample (ì´ì „ ê°’ ìœ ì§€)
    df_1h = df.resample("1H").ffill()

    # target_dtê°€ ë²”ìœ„ ë°–ì´ë©´ ê°€ì¥ ê°€ê¹Œìš´ ì‹œì ìœ¼ë¡œ ë³´ì •
    if target_dt < df_1h.index.min():
        chosen_ts = df_1h.index.min()
    elif target_dt > df_1h.index.max():
        chosen_ts = df_1h.index.max()
    else:
        idx = df_1h.index.get_indexer([target_dt], method="nearest")[0]
        chosen_ts = df_1h.index[idx]

    row = df_1h.loc[chosen_ts]

    # 2) ëŒ€ê¸°ì§ˆ (í˜„ì¬ê°’ ì‚¬ìš© â€“ ë‹¨ìˆœí™”)
    air_params = {
        "lat": lat,
        "lon": lon,
        "appid": OWM_API_KEY,
    }
    air_r = requests.get(OWM_AIR_URL, params=air_params)
    pm25 = 0.0
    pm10 = 0.0
    try:
        air_r.raise_for_status()
        air_data = air_r.json()
        first = air_data.get("list", [{}])[0]
        comps = first.get("components", {})
        pm25 = float(comps.get("pm2_5", 0.0))
        pm10 = float(comps.get("pm10", 0.0))
    except Exception:
        pm25 = 0.0
        pm10 = 0.0

    return {
        "temperature": float(row["temperature"]),
        "humidity": float(row["humidity"]),
        "wind_speed": float(row["wind_speed"]),
        "precipitation": float(row["precipitation"]),
        "pm25": pm25,
        "pm10": pm10,
        "raw_dt": chosen_ts.strftime("%Y-%m-%d %H:%M:%S"),
    }


# =========================
# ğŸš€ FastAPI ì•±
# =========================
app = FastAPI(
    title="OpenWeather ê¸°ë°˜ AI ìš´ë™ ì¶”ì²œ API",
    description="ìœ„ì¹˜ + ì‹œê°„ + ì‹¤ì‹œê°„ ì„ í˜¸ìš´ë™ + ë‚ ì”¨/ë¯¸ì„¸ë¨¼ì§€ë¡œ ìµœì  ìš´ë™ ì¶”ì²œ",
    version="1.0",
)


@app.get("/")
def home():
    return {"message": "ìš´ë™ ì¶”ì²œ API ì‘ë™ ì¤‘!"}


# =========================
# ğŸ§  í•µì‹¬ ì—”ë“œí¬ì¸íŠ¸
# =========================
@app.post("/recommend/by-location-and-user")
def recommend_by_location_and_user(req: LocationUserRequest):
    # 1) ìœ„ì¹˜ â†’ ìœ„/ê²½ë„
    lat, lon = geocode_owm(req.location_name)

    # 2) í•´ë‹¹ ì‹œì ì˜ ë‚ ì”¨ + ëŒ€ê¸°ì§ˆ
    weather = get_weather_from_owm(lat, lon, req.target_datetime)

    # 3) ê³„ì ˆ / ì‹œê°„ëŒ€ / season_code
    season_str = get_season_from_month(req.target_datetime.month)
    time_range_str = get_time_range_from_hour(req.target_datetime.hour)
    season_code = season_map.get(season_str, -1)

    # 4) XGBoost ì…ë ¥ ë§Œë“¤ê¸° (ë‚ ì”¨ ê¸°ë°˜ ì¹´í…Œê³ ë¦¬ ì˜ˆì¸¡ìš©)
    feature_cols = [
        "temperature",
        "humidity",
        "wind_speed",
        "precipitation",
        "pm25",
        "season_code",
    ]
    raw_features = [
        weather["temperature"],
        weather["humidity"],
        weather["wind_speed"],
        weather["precipitation"],
        weather["pm25"],
        season_code,
    ]
    scaled = scaler.transform([raw_features])
    X_input = pd.DataFrame(scaled, columns=feature_cols)

    # 5) XGBoostê°€ ì˜ˆì¸¡í•œ ì¹´í…Œê³ ë¦¬ (ë‚ ì”¨ ê¸°ë°˜)
    model_cat_id = category_model.predict(X_input)[0]
    model_cat = le_category.inverse_transform([model_cat_id])[0]

    # 6) ë¯¸ì„¸ë¨¼ì§€ + ë‚ ì”¨ ìƒíƒœ í‰ê°€ â†’ ì‹¤ë‚´/ì‹¤ì™¸ ê²°ì •
    temp = weather["temperature"]
    ws = weather["wind_speed"]
    precip = weather["precipitation"]
    pm25 = weather["pm25"]
    pm10 = weather["pm10"]
    pm_grade = classify_pm(pm25, pm10)

    # ë¹„, ê°•í’, ë„ˆë¬´ ì¶¥ê±°ë‚˜ ë”ìš°ë©´ "ë°–ì— ë‚˜ê°€ê¸° ì•ˆ ì¢‹ì€ ë‚ ì”¨"ë¡œ ê°„ì£¼
    is_rainy = precip > 0.0
    is_windy = ws >= 8.0         # 2~3ë‹¨ê³„ ì´ìƒ ë°”ëŒ
    is_too_cold = temp <= 0.0
    is_too_hot = temp >= 30.0
    is_bad_weather = is_rainy or is_windy or is_too_cold or is_too_hot

    # ê³µê¸° ì•ˆ ì¢‹ìŒ
    is_bad_air = pm_grade in ["ë‚˜ì¨", "ë§¤ìš° ë‚˜ì¨"]

    # ìµœì¢…ì ìœ¼ë¡œ ì‹¤ë‚´ë¥¼ ê°•í•˜ê²Œ ì¶”ì²œí•´ì•¼ í•˜ëŠ”ì§€ ì—¬ë¶€
    indoor_required = is_bad_weather or is_bad_air

    # 7) ì„ í˜¸ìš´ë™(favorites) ì •ì œ + ì¹´í…Œê³ ë¦¬ ì¡°íšŒ
    fav_list_raw = req.favorites or []
    fav_list = [
        f.strip().replace(",", "")
        for f in fav_list_raw
        if f and f.strip()
    ]

    fav_meta = activity_df[activity_df["activity_name"].isin(fav_list)].copy()
    fav_cats = list(fav_meta["category"].unique())

    reason_parts = []
    if fav_list:
        reason_parts.append(f"ì‚¬ìš©ì ì„ í˜¸ìš´ë™(ì‹¤ì‹œê°„ ì…ë ¥): {fav_list}")
    else:
        reason_parts.append("ì„ í˜¸ìš´ë™ì´ ì „ë‹¬ë˜ì§€ ì•Šì•„, ëª¨ë¸ì´ ì˜ˆì¸¡í•œ ì¹´í…Œê³ ë¦¬ë¥¼ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.")

    # 8) ì¹´í…Œê³ ë¦¬ ì„ íƒ ë¡œì§ (ì„ í˜¸ìš´ë™ + XGBoost + ì‹¤ë‚´/ì‹¤ì™¸ ì¡°ê±´)
    if fav_cats:
        # 8-1) ì„ í˜¸ìš´ë™ ì¹´í…Œê³ ë¦¬ê°€ í•˜ë‚˜ë¿ì´ë©´ ê·¸ê±¸ ê¸°ë³¸ìœ¼ë¡œ
        if len(fav_cats) == 1:
            base_cat = fav_cats[0]
            reason_parts.append(f"ë‘ ì„ í˜¸ìš´ë™ì˜ ì¹´í…Œê³ ë¦¬ê°€ ë™ì¼í•˜ì—¬ '{base_cat}' ì¹´í…Œê³ ë¦¬ë¥¼ ìš°ì„  ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.")
        else:
            # ë‘ ê°œ ì´ìƒì¸ ê²½ìš°
            if model_cat in fav_cats:
                base_cat = model_cat
                reason_parts.append(
                    f"XGBoostê°€ ì˜ˆì¸¡í•œ ì¹´í…Œê³ ë¦¬ '{model_cat}' ê°€ ì„ í˜¸ìš´ë™ ì¹´í…Œê³ ë¦¬ ì¤‘ í•˜ë‚˜ì—¬ì„œ ì´ë¥¼ ìš°ì„  ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤."
                )
            else:
                base_cat = fav_cats[0]
                reason_parts.append(
                    f"ì„ í˜¸ìš´ë™ ì¹´í…Œê³ ë¦¬ê°€ ì„œë¡œ ë‹¬ë¼, ê·¸ ì¤‘ ì²« ë²ˆì§¸ ì¹´í…Œê³ ë¦¬ '{base_cat}' ë¥¼ ê¸°ë³¸ìœ¼ë¡œ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤."
                )
        pred_category = base_cat
    else:
        # ì„ í˜¸ìš´ë™ì´ ë§¤í•‘ë˜ì§€ ì•Šìœ¼ë©´ â†’ ëª¨ë¸ ì¹´í…Œê³ ë¦¬ ì‚¬ìš©
        pred_category = model_cat
        reason_parts.append(
            f"ì„ í˜¸ìš´ë™ì´ í™œë™ ëª©ë¡ê³¼ ë§¤ì¹­ë˜ì§€ ì•Šì•„, XGBoostê°€ ì˜ˆì¸¡í•œ ì¹´í…Œê³ ë¦¬ '{model_cat}' ë¥¼ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤."
        )

    # 9) ì‹¤ë‚´/ì‹¤ì™¸ ìš°ì„  ê·œì¹™ ì„¤ëª…
    if indoor_required:
        reason_parts.append(
            f"ë‚ ì”¨/ëŒ€ê¸° ìƒíƒœê°€ ì¢‹ì§€ ì•Šì•„(ë¹„:{is_rainy}, ê°•í’:{is_windy}, ì¶”ì›€:{is_too_cold}, ë”ì›€:{is_too_hot}, ë¯¸ì„¸ë¨¼ì§€ë“±ê¸‰:{pm_grade}), ì‹¤ë‚´ ìš´ë™ì„ ìš°ì„  ê³ ë ¤í–ˆìŠµë‹ˆë‹¤."
        )
    else:
        reason_parts.append(
            f"ë‚ ì”¨ì™€ ê³µê¸° ì§ˆì´ ë¹„êµì  ì–‘í˜¸í•˜ì—¬, ì‹¤ì™¸ ìš´ë™ì„ ìš°ì„  ê³ ë ¤í–ˆìŠµë‹ˆë‹¤."
        )

    # 10) ìµœì¢… ì¹´í…Œê³ ë¦¬ì— ì†í•˜ëŠ” í›„ë³´ ìš´ë™ë“¤ í•„í„°ë§
    candidates = activity_df[activity_df["category"] == pred_category].copy()

    # ê³„ì ˆ í•„í„°
    cand_season = candidates[
        (candidates["season"].isna())
        | (candidates["season"].astype(str).str.contains(season_str))
    ]
    if not cand_season.empty:
        candidates = cand_season

    # ì‹œê°„ëŒ€ í•„í„°
    cand_time = candidates[
        (candidates["time_range"].isna())
        | (candidates["time_range"].astype(str).str.contains(time_range_str))
    ]
    if not cand_time.empty:
        candidates = cand_time

    # âœ… ì‹¤ë‚´/ì‹¤ì™¸ í•„í„° ì ìš©
    if indoor_required:
        # ì‹¤ë‚´ ìš°ì„ 
        indoor_cands = candidates[
            candidates["location_type"].astype(str).str.contains("ì‹¤ë‚´")
        ]
        if not indoor_cands.empty:
            candidates = indoor_cands
    else:
        # ì‹¤ì™¸ ìš°ì„ 
        outdoor_cands = candidates[
            candidates["location_type"].astype(str).str.contains("ì‹¤ì™¸")
        ]
        if not outdoor_cands.empty:
            candidates = outdoor_cands

    if candidates.empty:
        # ë§Œì•½ ìœ„ í•„í„°ë¡œ ë‹¤ ë‚ ì•„ê°€ë©´ -> ì¹´í…Œê³ ë¦¬ë§Œ ë§ëŠ” ì „ì²´ í›„ë³´ë¡œ ë³µêµ¬
        candidates = activity_df[activity_df["category"] == pred_category].copy()

    # 11) ìµœì¢… ìš´ë™ ì„ íƒ: ì¹´í…Œê³ ë¦¬ + (ì‹¤ë‚´/ì‹¤ì™¸) ì•ˆì—ì„œ ì„ í˜¸ìš´ë™ ìš°ì„ 
    recommended_activity = None
    fav_match_list: List[str] = []

    if fav_list:
        fav_in_cat = candidates[candidates["activity_name"].isin(fav_list)]
        if not fav_in_cat.empty:
            chosen = fav_in_cat.sample(1).iloc[0]
            recommended_activity = chosen["activity_name"]
            fav_match_list = list(fav_in_cat["activity_name"].unique())
            reason_parts.append(
                f"ì„ íƒëœ ì¹´í…Œê³ ë¦¬/ì‹¤ë‚´Â·ì‹¤ì™¸ ì¡°ê±´ ì•ˆì—ì„œ ì„ í˜¸ìš´ë™ê³¼ ì¼ì¹˜í•˜ëŠ” ìš´ë™ì„ ìš°ì„  ì¶”ì²œí–ˆìŠµë‹ˆë‹¤: {fav_match_list}"
            )

    if recommended_activity is None:
        chosen = candidates.sample(1).iloc[0]
        recommended_activity = chosen["activity_name"]
        reason_parts.append(
            f"ì„ í˜¸ìš´ë™ê³¼ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” í•­ëª©ì´ ì—†ì–´, ì„ íƒëœ ì¹´í…Œê³ ë¦¬/ì‹¤ë‚´Â·ì‹¤ì™¸ ì¡°ê±´ ì•ˆì—ì„œ ìš´ë™ì„ ë¬´ì‘ìœ„ë¡œ ì¶”ì²œí–ˆìŠµë‹ˆë‹¤."
        )

    reason = " / ".join(reason_parts)

    return {
        "ì…ë ¥ê°’": {
            "user_id": req.user_id,
            "location_name": req.location_name,
            "target_datetime": req.target_datetime.isoformat(),
            "favorites_from_request": fav_list,
        },
        "ì§€ì˜¤ì½”ë”©": {"ìœ„ë„": lat, "ê²½ë„": lon},
        "ì‚¬ìš©ëœ_ë‚ ì”¨": {
            "temperature": temp,
            "humidity": weather["humidity"],
            "wind_speed": ws,
            "precipitation": precip,
            "pm25": pm25,
            "pm10": pm10,
            "pm_grade": pm_grade,
            "season": season_str,
            "time_range": time_range_str,
            "owm_dt_txt": weather["raw_dt"],
            "is_rainy": is_rainy,
            "is_windy": is_windy,
            "is_too_cold": is_too_cold,
            "is_too_hot": is_too_hot,
            "is_bad_air": is_bad_air,
        },
        "XGBoost_ì˜ˆì¸¡_ì¹´í…Œê³ ë¦¬": model_cat,
        "ìµœì¢…_ì„ íƒ_ì¹´í…Œê³ ë¦¬": pred_category,
        "ì‹¤ë‚´_ìš°ì„ ì—¬ë¶€": indoor_required,
        "ì¶”ì²œ_ìš´ë™": recommended_activity,
        "ì¶”ì²œ_ê·¼ê±°": reason,
        "ë””ë²„ê·¸": {
            "favorites_raw": fav_list_raw,
            "favorites_clean": fav_list,
            "favorite_categories": fav_cats,
            "favorites_matched_in_category": fav_match_list,
        },
    }