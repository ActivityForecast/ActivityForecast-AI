# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15xUsIc96lG4x4uuG39sa5PhoT7xVnVjz
"""

# app.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from datetime import datetime, timedelta
from typing import List, Optional, Dict
import requests
import pandas as pd
import joblib
import random
from collections import Counter

# =====================================================
# 1. OpenWeather ì„¤ì • (ğŸ”‘ ì—¬ê¸° API í‚¤ ì§ì ‘ ë„£ê¸°)
# =====================================================
OWM_API_KEY = "9f8737894290204a7b2793f510443e46"  # <-- ë„¤ OpenWeather API Key

OWM_GEOCODING_URL = "http://api.openweathermap.org/geo/1.0/direct"
OWM_FORECAST_URL = "https://api.openweathermap.org/data/2.5/forecast"  # 5ì¼ / 3ì‹œê°„ ì˜ˆë³´
OWM_AIR_POLLUTION_URL = "http://api.openweathermap.org/data/2.5/air_pollution"

# =====================================================
# 2. FastAPI & CORS ì„¤ì •
# =====================================================
app = FastAPI(
    title="AI ê¸°ë°˜ ì‹¤ì‹œê°„ ë‚ ì”¨ & ë§ì¶¤ ìš´ë™ ì¶”ì²œ API",
    description="OpenWeather + XGBoost + ì‚¬ìš©ì ì„ í˜¸ë„ë¥¼ ì´ìš©í•œ ìš´ë™ ì¶”ì²œ ì„œë¹„ìŠ¤",
    version="1.0.0",
)

origins = [
    "http://localhost:3000",
    "http://127.0.0.1:3000",
    "http://144.24.73.5:8080",  # íŒ€ ì„œë²„
    "http://144.24.73.5",
    # "https://í”„ë¡ íŠ¸ì—”ë“œ-ë„ë©”ì¸ì£¼ì†Œ"  # ì‹¤ì œ ë°°í¬ í”„ë¡ íŠ¸ ìˆìœ¼ë©´ ì¶”ê°€
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# =====================================================
# 3. ëª¨ë¸ & ë°ì´í„° ë¡œë”©
# =====================================================
# category_model.pkl / feature_scaler.pkl / category_label_encoder.pkl
category_model = joblib.load("category_model.pkl")
scaler = joblib.load("feature_scaler.pkl")
le_category = joblib.load("category_label_encoder.pkl")

# í™œë™ ì •ë³´
activity_df = pd.read_csv("activity_information.csv")

activity_df = activity_df.rename(
    columns={
        "í™œë™ëª…": "activity_name",
        "í™œë™ì¹´í…Œê³ ë¦¬": "category",
        "ì¥ì†Œìœ í˜•": "location_type",
        "ë‚œì´ë„": "difficulty",
        "ì¶”ì²œê³„ì ˆ": "season",
        "ì í•©ì‹œê°„ëŒ€": "time_range",
    }
)

# í™œë™ëª… â†’ ì¹´í…Œê³ ë¦¬ ë§¤í•‘ (ì„ í˜¸ìš´ë™ â†’ ì¹´í…Œê³ ë¦¬ ê³„ì‚°ìš©)
activity_to_category: Dict[str, str] = {
    row["activity_name"]: row["category"]
    for _, row in activity_df.iterrows()
}

# =====================================================
# 4. ìœ í‹¸ í•¨ìˆ˜ë“¤ (ê³„ì ˆ, ì‹œê°„ëŒ€, ê³µê¸°ì§ˆ ë“±)
# =====================================================
def get_season_from_month(m: int) -> str:
    if 3 <= m <= 5:
        return "ë´„"
    if 6 <= m <= 8:
        return "ì—¬ë¦„"
    if 9 <= m <= 11:
        return "ê°€ì„"
    return "ê²¨ìš¸"


def get_time_range_from_hour(h: int) -> str:
    if 5 <= h < 12:
        return "ì˜¤ì „"
    if 12 <= h < 18:
        return "ì˜¤í›„"
    if 18 <= h < 23:
        return "ì €ë…"
    return "ì•¼ê°„"


def grade_pm(pm10: float, pm25: float) -> str:
    """
    í•œêµ­ í™˜ê²½ ê¸°ì¤€ ëŒ€ëµ ì°¸ê³ í•´ì„œ ë“±ê¸‰ ë¬¸ìì—´ ë¦¬í„´
    """
    # ì•„ì£¼ ê±°ì¹ ê²Œ ë‘˜ ì¤‘ ë” ë‚˜ìœ ë“±ê¸‰ ê¸°ì¤€ ì‚¬ìš©
    grade_score = 0  # 0: ì¢‹ìŒ, 1: ë³´í†µ, 2: ë‚˜ì¨, 3: ë§¤ìš° ë‚˜ì¨

    if pm10 > 150 or pm25 > 75:
        grade_score = 3
    elif pm10 > 80 or pm25 > 35:
        grade_score = 2
    elif pm10 > 30 or pm25 > 15:
        grade_score = 1
    else:
        grade_score = 0

    if grade_score == 0:
        return "ì¢‹ìŒ"
    if grade_score == 1:
        return "ë³´í†µ"
    if grade_score == 2:
        return "ë‚˜ì¨"
    return "ë§¤ìš° ë‚˜ì¨"


# =====================================================
# 5. OpenWeather Geocoding & Forecast & Air Pollution
# =====================================================
def geocode_owm(location_name: str):
    """
    í•œê¸€ ì§€ëª…ì„ OpenWeather Geocodingìœ¼ë¡œ ìœ„/ê²½ë„ ë³€í™˜
    1) "ì„±ë‚¨ì‹œ ìˆ˜ì •êµ¬,KR"
    2) "ì„±ë‚¨ì‹œ ìˆ˜ì •êµ¬"
    ìˆœì„œë¡œ ì‹œë„
    """
    for q in (f"{location_name},KR", location_name):
        params = {"q": q, "limit": 1, "appid": OWM_API_KEY}
        r = requests.get(OWM_GEOCODING_URL, params=params)
        r.raise_for_status()
        data = r.json()
        if data:
            lat = data[0]["lat"]
            lon = data[0]["lon"]
            return lat, lon

    raise ValueError(f"'{location_name}' ì— ëŒ€í•œ ì¢Œí‘œë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. (OpenWeatherMap Geocoding)")


def get_forecast_from_owm(lat: float, lon: float, target_dt: datetime):
    """
    5ì¼ / 3ì‹œê°„ ì˜ˆë³´ì—ì„œ target_dtì— ê°€ì¥ ê°€ê¹Œìš´ í•œ ê°œì˜ ì˜ˆë³´ë¥¼ ì„ íƒ
    """
    params = {
        "lat": lat,
        "lon": lon,
        "appid": OWM_API_KEY,
        "units": "metric",
        "lang": "kr",
    }
    r = requests.get(OWM_FORECAST_URL, params=params)
    r.raise_for_status()
    data = r.json()
    forecasts = data.get("list", [])

    if not forecasts:
        # ì˜ˆë³´ê°€ ì—†ìœ¼ë©´ ëŒ€ì¶© ê¸°ë³¸ê°’
        return {
            "temperature": 15.0,
            "humidity": 50.0,
            "wind_speed": 1.5,
            "precipitation": 0.0,
            "owm_dt_txt": None,
        }

    # target_dt ì™€ ê°€ì¥ ê°€ê¹Œìš´ ì‹œê°„ëŒ€ì˜ ì˜ˆë³´ ì°¾ê¸°
    best_item = None
    best_diff = None
    for item in forecasts:
        dt_txt = item.get("dt_txt")  # "2025-11-07 09:00:00" ê°™ì€ ë¬¸ìì—´
        if not dt_txt:
            continue
        f_dt = datetime.strptime(dt_txt, "%Y-%m-%d %H:%M:%S")
        diff = abs((f_dt - target_dt).total_seconds())
        if (best_diff is None) or (diff < best_diff):
            best_diff = diff
            best_item = item

    if best_item is None:
        best_item = forecasts[0]

    main = best_item.get("main", {})
    wind = best_item.get("wind", {})
    rain = best_item.get("rain", {})

    temp = main.get("temp", 15.0)
    hum = main.get("humidity", 50.0)
    ws = wind.get("speed", 1.5)
    precip = rain.get("3h", 0.0)

    return {
        "temperature": float(temp),
        "humidity": float(hum),
        "wind_speed": float(ws),
        "precipitation": float(precip),
        "owm_dt_txt": best_item.get("dt_txt"),
    }


def get_air_pollution_from_owm(lat: float, lon: float):
    """
    OpenWeather Air Pollution API ì‚¬ìš©í•´ì„œ PM10 / PM2.5 ê°€ì ¸ì˜¤ê¸°
    """
    params = {
        "lat": lat,
        "lon": lon,
        "appid": OWM_API_KEY,
    }
    r = requests.get(OWM_AIR_POLLUTION_URL, params=params)
    r.raise_for_status()
    data = r.json()
    lst = data.get("list", [])
    if not lst:
        return 0.0, 0.0

    comps = lst[0].get("components", {})
    pm10 = float(comps.get("pm10", 0.0))
    pm25 = float(comps.get("pm2_5", 0.0))
    return pm10, pm25


# =====================================================
# 6. Pydantic ìš”ì²­ ìŠ¤í‚¤ë§ˆ
# =====================================================
class RecommendRequest(BaseModel):
    user_id: str
    location_name: str
    target_datetime: datetime
    favorites: Optional[List[str]] = None  # ì‹¤ì‹œê°„ ì…ë ¥ ì„ í˜¸ìš´ë™ 2ê°œ ì •ë„


# =====================================================
# 7. ë©”ì¸ ì—”ë“œí¬ì¸íŠ¸
# =====================================================
@app.get("/")
def home():
    return {"message": "AI ê¸°ë°˜ ì‹¤ì‹œê°„ ë‚ ì”¨ & ë§ì¶¤ ìš´ë™ ì¶”ì²œ API ì‘ë™ ì¤‘!"}


@app.post("/recommend/by-location-and-user")
def recommend_by_location_and_user(req: RecommendRequest):
    """
    - ìœ„ì¹˜ ì´ë¦„ + ì‹œê°„ + ì„ í˜¸ìš´ë™ ë¦¬ìŠ¤íŠ¸(favorites)ë¥¼ ë°›ì•„ì„œ
    - OpenWeatherì—ì„œ ë‚ ì”¨ & ë¯¸ì„¸ë¨¼ì§€ ì •ë³´ ì¡°íšŒ
    - XGBoostë¡œ ì¹´í…Œê³ ë¦¬ ì˜ˆì¸¡
    - ì„ í˜¸ìš´ë™ & ë‚ ì”¨ & ê³µê¸°ì§ˆì„ ì¢…í•©í•´ ìµœì¢… ì¹´í…Œê³ ë¦¬ ì„ íƒ
    - ê·¸ ì¹´í…Œê³ ë¦¬ ì•ˆì—ì„œ ì„ í˜¸ìš´ë™ì„ ìš°ì„ ì ìœ¼ë¡œ ìš´ë™ëª… ì¶”ì²œ
    """

    # 1) ì„ í˜¸ìš´ë™ ë¬¸ìì—´ ì „ì²˜ë¦¬
    raw_favorites = req.favorites or []
    favorites_clean = []
    for f in raw_favorites:
        # ë’¤ì— ë¶™ì€ ì‰¼í‘œ/ê³µë°± ì œê±°
        name = f.replace(",", " ").strip()
        if name:
            favorites_clean.append(name)

    # 2) ìœ„ì¹˜ â†’ ìœ„/ê²½ë„
    lat, lon = geocode_owm(req.location_name)

    # 3) ë‚ ì”¨ ì˜ˆë³´ + ê³µê¸°ì§ˆ
    target_dt = req.target_datetime
    forecast = get_forecast_from_owm(lat, lon, target_dt)
    pm10, pm25 = get_air_pollution_from_owm(lat, lon)
    pm_grade = grade_pm(pm10, pm25)

    # 4) ê³„ì ˆ / ì‹œê°„ëŒ€
    season_str = get_season_from_month(target_dt.month)
    time_range_str = get_time_range_from_hour(target_dt.hour)
    season_code = {"ë´„": 0, "ì—¬ë¦„": 1, "ê°€ì„": 2, "ê²¨ìš¸": 3}.get(season_str, -1)

    # 5) ëª¨ë¸ ì…ë ¥ ë§Œë“¤ê¸°
    #    ğŸ‘‰ í•™ìŠµë•Œ ì‚¬ìš©í•œ feature ìˆœì„œì™€ ë™ì¼í•´ì•¼ í•¨
    numeric_cols = ["temperature", "humidity", "wind_speed", "precipitation", "pm25", "pm10"]
    raw_numeric = [
        forecast["temperature"],
        forecast["humidity"],
        forecast["wind_speed"],
        forecast["precipitation"],
        pm25,
        pm10,
    ]
    scaled = scaler.transform([raw_numeric])[0]  # shape: (n_features,)
    X_input = pd.DataFrame([scaled], columns=numeric_cols)
    X_input["season_code"] = season_code

    # 6) XGBoostë¡œ í™˜ê²½ ê¸°ë°˜ ì¹´í…Œê³ ë¦¬ ì˜ˆì¸¡
    pred_cat_id = category_model.predict(X_input)[0]
    env_category = le_category.inverse_transform([pred_cat_id])[0]

    # 7) ê³µê¸°ì§ˆ ê¸°ë°˜ ì¶”ì²œ ì¹´í…Œê³ ë¦¬(ì‹¤ë‚´/ì‹¤ì™¸) ê²½í–¥
    pm_preferred_category: Optional[str] = None
    if pm_grade in ["ë‚˜ì¨", "ë§¤ìš° ë‚˜ì¨"]:
        pm_preferred_category = "í”¼íŠ¸ë‹ˆìŠ¤"  # ì‹¤ë‚´ ìš´ë™ ìœ„ì£¼

    # 8) ì„ í˜¸ìš´ë™ â†’ ì¹´í…Œê³ ë¦¬ ì§‘ê³„
    favorite_categories = []
    for fav in favorites_clean:
        cat = activity_to_category.get(fav)
        if cat:
            favorite_categories.append(cat)

    fav_cat_counter = Counter(favorite_categories)  # ì˜ˆ: {"ìœ ì‚°ì†Œ": 1, "êµ¬ê¸°ìŠ¤í¬ì¸ ": 1, ...}

    # 9) í›„ë³´ ì¹´í…Œê³ ë¦¬ë“¤ì— ëŒ€í•´ ì ìˆ˜ ê³„ì‚° (ì„ í˜¸ + í™˜ê²½ + ê³µê¸°ì§ˆ)
    candidate_cats = set(favorite_categories)
    candidate_cats.add(env_category)
    if pm_preferred_category:
        candidate_cats.add(pm_preferred_category)

    best_cat = env_category
    best_score = -1

    for cat in candidate_cats:
        score = 0
        # ì„ í˜¸ ê°œìˆ˜ë§Œí¼ ê°€ì‚°
        score += fav_cat_counter.get(cat, 0)
        # í™˜ê²½ ëª¨ë¸ì´ ë½‘ì€ ì¹´í…Œê³ ë¦¬ì™€ ì¼ì¹˜í•˜ë©´ +1
        if cat == env_category:
            score += 1
        # ê³µê¸°ì§ˆ ê¸°ì¤€ ìš°ì„  ì¹´í…Œê³ ë¦¬ì™€ ì¼ì¹˜í•˜ë©´ +1
        if pm_preferred_category and cat == pm_preferred_category:
            score += 1

        if score > best_score:
            best_score = score
            best_cat = cat

    final_category = best_cat

    # 10) í•´ë‹¹ ì¹´í…Œê³ ë¦¬ ë‚´ í›„ë³´ ìš´ë™ í•„í„°ë§
    candidates = activity_df[activity_df["category"] == final_category].copy()

    # ê³„ì ˆ í•„í„°
    if "season" in candidates.columns:
        filtered = candidates[
            candidates["season"].isna()
            | candidates["season"].astype(str).str.contains(season_str)
        ]
        if not filtered.empty:
            candidates = filtered

    # ì‹œê°„ëŒ€ í•„í„°
    if "time_range" in candidates.columns:
        filtered = candidates[
            candidates["time_range"].isna()
            | candidates["time_range"].astype(str).str.contains(time_range_str)
        ]
        if not filtered.empty:
            candidates = filtered

    # 11) ìµœì¢… ìš´ë™ ì„ íƒ ë¡œì§
    reason_parts = []

    if favorites_clean:
        reason_parts.append(f"ì‚¬ìš©ì ì„ í˜¸ìš´ë™(ì‹¤ì‹œê°„ ì…ë ¥): {favorites_clean}")

    # 1ìˆœìœ„: ì„ í˜¸ìš´ë™ ì¤‘ì—ì„œ í˜„ì¬ ì¹´í…Œê³ ë¦¬ + í•„í„°ë¥¼ ë§Œì¡±í•˜ëŠ” ìš´ë™
    matched_favs = [
        fav for fav in favorites_clean
        if fav in candidates["activity_name"].values
    ]

    if matched_favs:
        chosen_activity = matched_favs[0]
        reason_parts.append(
            f"ì„ í˜¸ìš´ë™ ì¤‘ì—ì„œ í˜„ì¬ ì¹´í…Œê³ ë¦¬/ì¡°ê±´ì— ë§ëŠ” ìš´ë™ì„ ìš°ì„  ì¶”ì²œí–ˆìŠµë‹ˆë‹¤: {matched_favs}"
        )
    else:
        # 2ìˆœìœ„: ê·¸ëƒ¥ í›„ë³´ ì¤‘ì—ì„œ ëœë¤
        if candidates.empty:
            # í˜¹ì‹œ í•„í„°ë§í•˜ë‹¤ê°€ ë¹„ë©´, ê°™ì€ ì¹´í…Œê³ ë¦¬ ì „ì²´ì—ì„œ ëœë¤
            candidates = activity_df[activity_df["category"] == final_category]
        if candidates.empty:
            chosen_activity = None
            reason_parts.append("í•´ë‹¹ ì¡°ê±´ì— ë§ëŠ” ìš´ë™ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
        else:
            row = candidates.sample(1).iloc[0]
            chosen_activity = row["activity_name"]
            reason_parts.append("ì„ í˜¸ìš´ë™ê³¼ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” í›„ë³´ê°€ ì—†ì–´, ì¹´í…Œê³ ë¦¬ ë‚´ ìš´ë™ ì¤‘ í•˜ë‚˜ë¥¼ ë¬´ì‘ìœ„ë¡œ ì¶”ì²œí–ˆìŠµë‹ˆë‹¤.")

    # ê³µê¸°ì§ˆ ì„¤ëª… ì¶”ê°€
    if pm_preferred_category == "í”¼íŠ¸ë‹ˆìŠ¤":
        reason_parts.append("ë¯¸ì„¸ë¨¼ì§€Â·ì´ˆë¯¸ì„¸ë¨¼ì§€ ìˆ˜ì¹˜ê°€ ë†’ì•„ ì‹¤ë‚´ ìš´ë™(í”¼íŠ¸ë‹ˆìŠ¤)ì„ ìš°ì„  ê³ ë ¤í–ˆìŠµë‹ˆë‹¤.")

    return {
        "ì…ë ¥ê°’": {
            "user_id": req.user_id,
            "location_name": req.location_name,
            "target_datetime": req.target_datetime.isoformat(),
            "favorites_from_request": favorites_clean,
        },
        "ì§€ì˜¤ì½”ë”©": {
            "ìœ„ë„": lat,
            "ê²½ë„": lon,
        },
        "ì‚¬ìš©ëœ_ë‚ ì”¨": {
            "temperature": forecast["temperature"],
            "humidity": forecast["humidity"],
            "wind_speed": forecast["wind_speed"],
            "precipitation": forecast["precipitation"],
            "pm25": pm25,
            "pm10": pm10,
            "pm_grade": pm_grade,
            "season": season_str,
            "time_range": time_range_str,
            "owm_dt_txt": forecast["owm_dt_txt"],
        },
        "ì˜ˆì¸¡_ì¹´í…Œê³ ë¦¬_ì›ë³¸": env_category,
        "ì‹¤ì œ_ì‚¬ìš©_ì¹´í…Œê³ ë¦¬": final_category,
        "ì¶”ì²œ_ìš´ë™": chosen_activity,
        "ì¶”ì²œ_ê·¼ê±°": " / ".join(reason_parts),
        "ë””ë²„ê·¸": {
            "favorite_categories_counter": dict(fav_cat_counter),
            "pm_preferred_category": pm_preferred_category,
        },
    }