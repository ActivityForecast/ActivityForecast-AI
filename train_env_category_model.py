# -*- coding: utf-8 -*-
"""train_env_category_model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mq3_WaDona8fBLf8j-oHV_OU4a08Wfyj
"""

import pandas as pd
import numpy as np

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler, LabelEncoder
from sklearn.metrics import accuracy_score, f1_score

from xgboost import XGBClassifier
import joblib

# =========================================
# 1. 데이터 로드 & 기본 전처리
#    (환경 기반 카테고리 예측용)
# =========================================
weather = pd.read_csv("Weather_Conditions.csv")

print("원본 컬럼:", weather.columns.tolist())

# 컬럼 이름 정리 (app.py와 동일하게 맞추기)
weather = weather.rename(
    columns={
        "기온(°C)": "temperature",
        "습도(%)": "humidity",
        "풍속(m/s)": "wind_speed",
        "강수량(mm)": "precipitation",
        "Air_PM2.5_수치": "pm25",
        "날짜시간": "dt",
    }
)

if "dt" not in weather.columns:
    raise ValueError(f"'dt' 컬럼이 없습니다. 현재 컬럼들: {weather.columns.tolist()}")

# 날짜 파싱
weather["dt"] = pd.to_datetime(weather["dt"], errors="coerce")
weather = weather.dropna(subset=["dt"])

# 결측치 처리
for col in ["temperature", "humidity", "wind_speed", "precipitation", "pm25"]:
    if col in weather.columns:
        weather[col] = weather[col].fillna(0)

# =========================================
# 2. 계절 코드 파생 (환경 특징 강화)
# =========================================
def get_season_from_month(m: int) -> str:
    if 3 <= m <= 5:
        return "봄"
    if 6 <= m <= 8:
        return "여름"
    if 9 <= m <= 11:
        return "가을"
    return "겨울"

season_map = {"봄": 0, "여름": 1, "가을": 2, "겨울": 3}

weather["season_str"] = weather["dt"].dt.month.apply(get_season_from_month)
weather["season_code"] = weather["season_str"].map(season_map)

# =========================================
# 3. 도메인 규칙으로 pseudo-label 생성
#    → "환경이 이럴 때 어떤 유형 활동이 적합한지"를 정의
#    → XGBoost는 이걸 모방하는 환경 기반 카테고리 예측 모델
# =========================================
def env_to_category(row):
    t = row["temperature"]
    h = row["humidity"]
    w = row["wind_speed"]
    p = row["precipitation"]
    pm = row["pm25"]

    # 환경이 안 좋으면 → 실내 피트니스
    if p >= 1.0 or t <= 0 or t >= 33 or pm >= 50:
        return "피트니스"

    # 바람이 충분하고 따뜻하면 → 익스트림스포츠
    if 15 <= t <= 30 and w >= 4:
        return "익스트림스포츠"

    # 적당한 온도/바람/습도 → 구기스포츠
    if 12 <= t <= 28 and 1 <= w < 4 and h <= 75:
        return "구기스포츠"

    # 나머지 → 유산소
    return "유산소"

weather["category"] = weather.apply(env_to_category, axis=1)

print("환경 기반 pseudo 카테고리 분포:")
print(weather["category"].value_counts())

# =========================================
# 4. 입력 피처 / 타깃 구성
#    (환경 특징 → 카테고리)
# =========================================
numeric_cols = ["temperature", "humidity", "wind_speed", "precipitation", "pm25"]
feature_cols = numeric_cols + ["season_code"]

for col in numeric_cols:
    if col not in weather.columns:
        weather[col] = 0.0

X = weather[feature_cols].copy()
y = weather["category"].astype(str)

# =========================================
# 5. 스케일링 + 레이블 인코딩
# =========================================
scaler = MinMaxScaler()
X_scaled = scaler.fit_transform(X)

le_category = LabelEncoder()
y_encoded = le_category.fit_transform(y)

# =========================================
# 6. Train / Test Split
# =========================================
X_train, X_test, y_train, y_test = train_test_split(
    X_scaled,
    y_encoded,
    test_size=0.2,
    random_state=42,
    stratify=y_encoded,
)

# =========================================
# 7. 클래스 불균형 보정 (선택)
# =========================================
class_counts = pd.Series(y_train).value_counts()
class_weight = {
    cls: len(y_train) / (len(class_counts) * cnt)
    for cls, cnt in class_counts.items()
}
sample_weights = np.array([class_weight[cls] for cls in y_train])

# =========================================
# 8. XGBoost 모델 정의
#    (보고서의 하이퍼파라미터 범위 반영)
# =========================================
model = XGBClassifier(
    objective="multi:softmax",
    learning_rate=0.03,   # 0.01~0.05 범위 내
    max_depth=4,          # 3~6 범위 내
    n_estimators=800,     # 500~1000 범위 내
    subsample=0.8,        # 0.7~0.9 범위 내
    colsample_bytree=0.8,
    random_state=42,
)

# =========================================
# 9. 학습
# =========================================
model.fit(X_train, y_train, sample_weight=sample_weights)

# =========================================
# 10. 평가 (환경 기반 카테고리 예측 성능)
# =========================================
y_pred = model.predict(X_test)

acc = accuracy_score(y_test, y_pred)
f1 = f1_score(y_test, y_pred, average="weighted")

print("✅ 환경 기반 카테고리 예측 Accuracy:", acc)
print("✅ 환경 기반 카테고리 예측 F1 Score:", f1)

# =========================================
# 11. 모델 / 스케일러 / 인코더 저장
#     → app.py에서 '환경 기반 카테고리 예측 블록'으로 사용
# =========================================
joblib.dump(model, "category_model.pkl")
joblib.dump(scaler, "feature_scaler.pkl")
joblib.dump(le_category, "category_label_encoder.pkl")

print("🎯 환경 기반 카테고리 모델 & 전처리 객체 저장 완료!")
print("저장 파일: category_model.pkl, feature_scaler.pkl, category_label_encoder.pkl")